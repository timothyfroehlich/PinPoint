# Migration v3

## RLS Hardening (Simple Description)

We’re moving from a hybrid model (manual organizationId filters in queries + partially permissive local RLS) to a single authoritative security layer: database Row Level Security enforced uniformly in every environment. Supabase will supply the tenant boundary through `auth.jwt()` app_metadata (organizationId). Both local and production SQL policy files will be unified so local development no longer relies on application predicates for isolation.

Concretely, we will (1) harden the local RLS scripts to match production (replace permissive `USING (true)` policies with real org‑scoped predicates and proper insertion triggers), (2) guarantee every authenticated user session has `organizationId` in app_metadata (adding a helper to set/verify it), and (3) remove all manual `organizationId` WHERE clauses and service constructor parameters that exist solely for scoping. After this, queries express only business logic; the database enforces tenant isolation transparently.

Validation shifts to RLS-focused tests: cross‑org negative access checks, pgTAP / SQL policy assertions, and a leak test confirming no rows from another org are visible even when IDs are guessed. A small CI guard will fail if new manual org filters reappear. The outcome is simpler code, reduced risk of hidden policy gaps, and a single, auditable security boundary.

## Very Hardening

We’re finishing the database migration by making the database—not the application—the single source of truth for organization boundaries. Right now the code still sprinkles manual organizationId filters through queries and relies on a lenient local RLS setup. In v3 we unify everything: local and production both use the same strict Row Level Security policies, every authenticated session always carries one “active organization” in Supabase app_metadata, and the code stops adding organization WHERE clauses. A user can belong to many orgs, but only one is active per session; switching orgs just updates that metadata and the database automatically scopes results.

Once this is in place the code becomes cleaner (queries show only business rules), the risk of accidental cross‑org leaks drops sharply, and security reviews focus on one auditable layer: the SQL policies. We’ll prove it with a small test suite: (1) setup helpers ensure an active org is always present, (2) cross‑org access tests confirm rows from another org never appear even if IDs are guessed, (3) a leak scan/CI guard fails if new manual org filters creep back in. The outcome is simpler code, stronger isolation, and a predictable pathway for future features like org switching or admin oversight without rewriting queries.
