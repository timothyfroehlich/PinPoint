# Task 14: Implement Collections System

## Prerequisites

**REQUIRED**: Read and understand `docs/planning/backend_impl_plan.md` before starting this task.

**Multi-Agent Coordination**: This task is part of Phase 3D development. See @MULTI_AGENT_WORKFLOW.md for complete worktree setup, sync procedures, and coordination guidelines.

## Workflow

- **Base Branch**: `epic/backend-refactor`
- **Task Branch**: `task/14-implement-collections-system`
- **PR Target**: `epic/backend-refactor` (NOT main)
- **Worktree**: `~/Code/PinPoint-worktrees/task-14-implement-collections-system/`

## Dependencies

- Task 12 (QR Code System) must be completed first (Machine model conflict)
- Independent of other tasks after Machine model conflicts resolved

## Objective

Implement the collections system to support advanced machine grouping and filtering as described in CUJs 7.1-7.3 and the UI Architecture Plan. This enables organizations to create manual collections (e.g., "Front Room", "Back Bar") and auto-generated collections (e.g., "Manufacturer", "Era") for powerful filtering on location pages.

## Status

- [ ] In Progress
- [ ] Completed

## Current Requirements from CUJs

### 7.1 Structuring a Location with Collections

"An admin edits a location to create several manual collections (e.g., 'Front Room,' 'Back Bar') within the 'Rooms' collection group."

### 7.2 Enabling an Auto-Collection

"An admin navigates to the organization settings and enables the 'Manufacturer' collection group, making it visible as a filter option on all public location pages."

### 7.3 Filtering by Collection

"A public user on a location page expands the 'Manufacturer' drawer and clicks 'Bally' to see all machines made by that manufacturer."

## Implementation Steps

### 1. Enhance Collection Models in Schema

Update `prisma/schema.prisma`:

```prisma
model Collection {
  id        String   @id @default(cuid())
  name      String   // e.g., "Front Room", "Bally", "1980s"
  typeId    String
  locationId String? // null for auto-collections (organization-wide)
  isSmart   Boolean  @default(false) // For 1.x Smart Collections
  isManual  Boolean  @default(true)  // Manual vs auto-generated

  // Manual collection fields
  description String? // Optional description
  sortOrder   Int     @default(0) // For custom ordering

  // Auto-collection fields
  filterCriteria Json? // Criteria for auto-collections: { "manufacturer": "Bally" }

  type     CollectionType @relation(fields: [typeId], references: [id], onDelete: Cascade)
  location Location?      @relation(fields: [locationId], references: [id], onDelete: Cascade)
  machines Machine[]

  @@unique([name, typeId, locationId]) // Prevent duplicate names within type/location
  @@index([locationId, typeId])
}

model CollectionType {
  id             String @id @default(cuid())
  name           String // e.g., "Rooms", "Manufacturer", "Era", "Genre"
  organizationId String
  isAutoGenerated Boolean @default(false) // Auto vs manual collection type
  isEnabled       Boolean @default(true)   // Can be disabled in org settings

  // Auto-generation settings
  sourceField     String? // Field to generate from: "manufacturer", "year", etc.
  generationRules Json?   // Rules for auto-generation

  // Display settings
  displayName     String? // Human-readable name for UI
  description     String? // Description for admin interface
  sortOrder       Int     @default(0) // Order on location pages

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  collections  Collection[]

  @@unique([name, organizationId])
}
```

### 2. Update Machine Model for Collections

Update Machine model to support collection membership:

```prisma
model Machine {
  // ... existing fields

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  location     Location     @relation(fields: [locationId], references: [id])
  model        Model        @relation(fields: [modelId], references: [id])
  owner        User?        @relation("MachineOwner", fields: [ownerId], references: [id])
  issues       Issue[]
  collections  Collection[] // Many-to-many with collections
  movements    MachineMovement[]

  // Collection-related computed fields (for auto-collections)
  @@index([organizationId, locationId])
  @@index([modelId]) // For manufacturer-based collections
}
```

### 3. Update Location Model

Add collections relation to Location:

```prisma
model Location {
  // ... existing fields

  organization     Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  machines         Machine[]
  collections      Collection[] // Manual collections specific to this location
  movementsFrom    MachineMovement[] @relation("MovementFrom")
  movementsTo      MachineMovement[] @relation("MovementTo")
}
```

### 4. Create CollectionService

Create `src/server/services/collectionService.ts`:

```typescript
import { type PrismaClient } from "@prisma/client";

export interface CreateCollectionData {
  name: string;
  typeId: string;
  locationId?: string;
  description?: string;
  isManual: boolean;
  filterCriteria?: any;
}

export interface CollectionWithMachines {
  id: string;
  name: string;
  type: {
    id: string;
    name: string;
    displayName: string | null;
  };
  machineCount: number;
  machines?: Array<{
    id: string;
    model: {
      name: string;
      manufacturer: string | null;
    };
  }>;
}

export class CollectionService {
  constructor(private prisma: PrismaClient) {}

  /**
   * Get collections for a location (for public filtering)
   */
  async getLocationCollections(
    locationId: string,
    organizationId: string,
  ): Promise<{
    manual: CollectionWithMachines[];
    auto: CollectionWithMachines[];
  }> {
    // Get enabled collection types for organization
    const enabledTypes = await this.prisma.collectionType.findMany({
      where: {
        organizationId,
        isEnabled: true,
      },
      orderBy: {
        sortOrder: "asc",
      },
    });

    const manual: CollectionWithMachines[] = [];
    const auto: CollectionWithMachines[] = [];

    for (const type of enabledTypes) {
      const collections = await this.prisma.collection.findMany({
        where: {
          typeId: type.id,
          OR: [
            { locationId }, // Location-specific collections
            { locationId: null, isManual: false }, // Organization-wide auto-collections
          ],
        },
        include: {
          type: true,
          _count: {
            select: {
              machines: {
                where: {
                  locationId, // Only count machines at this location
                },
              },
            },
          },
        },
        orderBy: {
          sortOrder: "asc",
        },
      });

      for (const collection of collections) {
        const collectionData: CollectionWithMachines = {
          id: collection.id,
          name: collection.name,
          type: {
            id: collection.type.id,
            name: collection.type.name,
            displayName: collection.type.displayName,
          },
          machineCount: collection._count.machines,
        };

        if (collection.isManual) {
          manual.push(collectionData);
        } else {
          auto.push(collectionData);
        }
      }
    }

    return { manual, auto };
  }

  /**
   * Get machines in a collection at a specific location
   */
  async getCollectionMachines(
    collectionId: string,
    locationId: string,
  ): Promise<
    Array<{
      id: string;
      model: {
        name: string;
        manufacturer: string | null;
        year: number | null;
      };
    }>
  > {
    return this.prisma.machine.findMany({
      where: {
        locationId,
        collections: {
          some: {
            id: collectionId,
          },
        },
      },
      include: {
        model: true,
      },
      orderBy: {
        model: {
          name: "asc",
        },
      },
    });
  }

  /**
   * Create a manual collection
   */
  async createManualCollection(
    organizationId: string,
    data: CreateCollectionData,
  ): Promise<Collection> {
    return this.prisma.collection.create({
      data: {
        name: data.name,
        typeId: data.typeId,
        locationId: data.locationId,
        description: data.description,
        isManual: true,
        isSmart: false,
      },
    });
  }

  /**
   * Add machines to a manual collection
   */
  async addMachinesToCollection(
    collectionId: string,
    machineIds: string[],
  ): Promise<void> {
    await this.prisma.collection.update({
      where: { id: collectionId },
      data: {
        machines: {
          connect: machineIds.map((id) => ({ id })),
        },
      },
    });
  }

  /**
   * Generate auto-collections for an organization
   */
  async generateAutoCollections(organizationId: string): Promise<{
    generated: number;
    updated: number;
  }> {
    const autoTypes = await this.prisma.collectionType.findMany({
      where: {
        organizationId,
        isAutoGenerated: true,
        isEnabled: true,
      },
    });

    let generated = 0;
    let updated = 0;

    for (const type of autoTypes) {
      if (type.sourceField === "manufacturer") {
        const result = await this.generateManufacturerCollections(type);
        generated += result.generated;
        updated += result.updated;
      } else if (type.sourceField === "year") {
        const result = await this.generateYearCollections(type);
        generated += result.generated;
        updated += result.updated;
      }
    }

    return { generated, updated };
  }

  /**
   * Generate manufacturer-based collections
   */
  private async generateManufacturerCollections(
    collectionType: CollectionType,
  ): Promise<{ generated: number; updated: number }> {
    // Get all unique manufacturers for machines in this organization
    const manufacturers = await this.prisma.machine.findMany({
      where: {
        organizationId: collectionType.organizationId,
        model: {
          manufacturer: {
            not: null,
          },
        },
      },
      select: {
        model: {
          select: {
            manufacturer: true,
          },
        },
      },
      distinct: ["modelId"],
    });

    const uniqueManufacturers = [
      ...new Set(
        manufacturers
          .map((m) => m.model.manufacturer)
          .filter((m): m is string => m !== null),
      ),
    ];

    let generated = 0;
    let updated = 0;

    for (const manufacturer of uniqueManufacturers) {
      // Check if collection already exists
      const existing = await this.prisma.collection.findFirst({
        where: {
          name: manufacturer,
          typeId: collectionType.id,
          locationId: null, // Organization-wide
        },
      });

      if (!existing) {
        // Create new collection
        const collection = await this.prisma.collection.create({
          data: {
            name: manufacturer,
            typeId: collectionType.id,
            locationId: null,
            isManual: false,
            isSmart: false,
            filterCriteria: { manufacturer },
          },
        });

        // Add all machines with this manufacturer
        const machines = await this.prisma.machine.findMany({
          where: {
            organizationId: collectionType.organizationId,
            model: {
              manufacturer,
            },
          },
          select: { id: true },
        });

        await this.prisma.collection.update({
          where: { id: collection.id },
          data: {
            machines: {
              connect: machines.map((m) => ({ id: m.id })),
            },
          },
        });

        generated++;
      } else {
        // Update existing collection with new machines
        const machines = await this.prisma.machine.findMany({
          where: {
            organizationId: collectionType.organizationId,
            model: {
              manufacturer,
            },
          },
          select: { id: true },
        });

        await this.prisma.collection.update({
          where: { id: existing.id },
          data: {
            machines: {
              set: machines.map((m) => ({ id: m.id })),
            },
          },
        });

        updated++;
      }
    }

    return { generated, updated };
  }

  /**
   * Generate year/era-based collections
   */
  private async generateYearCollections(
    collectionType: CollectionType,
  ): Promise<{ generated: number; updated: number }> {
    // Define eras
    const eras = [
      { name: "1970s", start: 1970, end: 1979 },
      { name: "1980s", start: 1980, end: 1989 },
      { name: "1990s", start: 1990, end: 1999 },
      { name: "2000s", start: 2000, end: 2009 },
      { name: "2010s", start: 2010, end: 2019 },
      { name: "2020s", start: 2020, end: 2029 },
    ];

    let generated = 0;
    let updated = 0;

    for (const era of eras) {
      // Check if collection exists
      const existing = await this.prisma.collection.findFirst({
        where: {
          name: era.name,
          typeId: collectionType.id,
          locationId: null,
        },
      });

      const machines = await this.prisma.machine.findMany({
        where: {
          organizationId: collectionType.organizationId,
          model: {
            year: {
              gte: era.start,
              lte: era.end,
            },
          },
        },
        select: { id: true },
      });

      if (machines.length === 0) continue; // Skip empty eras

      if (!existing) {
        const collection = await this.prisma.collection.create({
          data: {
            name: era.name,
            typeId: collectionType.id,
            locationId: null,
            isManual: false,
            isSmart: false,
            filterCriteria: { yearStart: era.start, yearEnd: era.end },
          },
        });

        await this.prisma.collection.update({
          where: { id: collection.id },
          data: {
            machines: {
              connect: machines.map((m) => ({ id: m.id })),
            },
          },
        });

        generated++;
      } else {
        await this.prisma.collection.update({
          where: { id: existing.id },
          data: {
            machines: {
              set: machines.map((m) => ({ id: m.id })),
            },
          },
        });

        updated++;
      }
    }

    return { generated, updated };
  }

  /**
   * Enable/disable a collection type for an organization
   */
  async toggleCollectionType(
    collectionTypeId: string,
    enabled: boolean,
  ): Promise<void> {
    await this.prisma.collectionType.update({
      where: { id: collectionTypeId },
      data: { isEnabled: enabled },
    });
  }

  /**
   * Get organization's collection types for admin management
   */
  async getOrganizationCollectionTypes(organizationId: string): Promise<
    Array<{
      id: string;
      name: string;
      displayName: string | null;
      isAutoGenerated: boolean;
      isEnabled: boolean;
      collectionCount: number;
    }>
  > {
    return this.prisma.collectionType
      .findMany({
        where: { organizationId },
        include: {
          _count: {
            select: {
              collections: true,
            },
          },
        },
        orderBy: {
          sortOrder: "asc",
        },
      })
      .then((types) =>
        types.map((type) => ({
          id: type.id,
          name: type.name,
          displayName: type.displayName,
          isAutoGenerated: type.isAutoGenerated,
          isEnabled: type.isEnabled,
          collectionCount: type._count.collections,
        })),
      );
  }
}
```

### 5. Create Collection tRPC Router

Create `src/server/api/routers/collection.ts`:

```typescript
import { z } from "zod";

import {
  createTRPCRouter,
  publicProcedure,
  organizationProcedure,
  organizationManageProcedure,
  locationEditProcedure,
} from "~/server/api/trpc";
import { CollectionService } from "~/server/services/collectionService";

export const collectionRouter = createTRPCRouter({
  // Public: Get collections for location filtering
  getForLocation: publicProcedure
    .input(
      z.object({
        locationId: z.string(),
        organizationId: z.string(),
      }),
    )
    .query(async ({ ctx, input }) => {
      const service = new CollectionService(ctx.db);
      return service.getLocationCollections(
        input.locationId,
        input.organizationId,
      );
    }),

  // Get machines in a collection
  getMachines: publicProcedure
    .input(
      z.object({
        collectionId: z.string(),
        locationId: z.string(),
      }),
    )
    .query(async ({ ctx, input }) => {
      const service = new CollectionService(ctx.db);
      return service.getCollectionMachines(
        input.collectionId,
        input.locationId,
      );
    }),

  // Create manual collection
  createManual: locationEditProcedure
    .input(
      z.object({
        name: z.string().min(1).max(50),
        typeId: z.string(),
        locationId: z.string().optional(),
        description: z.string().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const service = new CollectionService(ctx.db);
      return service.createManualCollection(ctx.organization.id, {
        name: input.name,
        typeId: input.typeId,
        locationId: input.locationId,
        description: input.description,
        isManual: true,
      });
    }),

  // Add machines to collection
  addMachines: locationEditProcedure
    .input(
      z.object({
        collectionId: z.string(),
        machineIds: z.array(z.string()),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const service = new CollectionService(ctx.db);
      await service.addMachinesToCollection(
        input.collectionId,
        input.machineIds,
      );
      return { success: true };
    }),

  // Generate auto-collections
  generateAuto: organizationManageProcedure.mutation(async ({ ctx }) => {
    const service = new CollectionService(ctx.db);
    return service.generateAutoCollections(ctx.organization.id);
  }),

  // Get organization collection types for admin
  getTypes: organizationProcedure.query(async ({ ctx }) => {
    const service = new CollectionService(ctx.db);
    return service.getOrganizationCollectionTypes(ctx.organization.id);
  }),

  // Toggle collection type
  toggleType: organizationManageProcedure
    .input(
      z.object({
        collectionTypeId: z.string(),
        enabled: z.boolean(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const service = new CollectionService(ctx.db);
      await service.toggleCollectionType(input.collectionTypeId, input.enabled);
      return { success: true };
    }),
});
```

### 6. Update Seed Data for Collection Types

Update `prisma/seed.ts` to create default collection types:

```typescript
// Create default collection types for each organization
const defaultCollectionTypes = [
  {
    name: "Rooms",
    displayName: "Rooms",
    isAutoGenerated: false,
    isEnabled: true,
    sortOrder: 1,
  },
  {
    name: "Manufacturer",
    displayName: "Manufacturer",
    isAutoGenerated: true,
    sourceField: "manufacturer",
    isEnabled: false, // Disabled by default, admin can enable
    sortOrder: 2,
  },
  {
    name: "Era",
    displayName: "Era",
    isAutoGenerated: true,
    sourceField: "year",
    isEnabled: false,
    sortOrder: 3,
  },
];

for (const org of organizations) {
  for (const typeData of defaultCollectionTypes) {
    await prisma.collectionType.create({
      data: {
        ...typeData,
        organizationId: org.id,
      },
    });
  }
}
```

### 7. Database Migration

```bash
# Push schema changes
npm run db:push

# Reset database with new schema
npm run db:reset
```

## Validation Steps

### 1. TypeScript Compilation

```bash
npm run typecheck
# Should pass without collection-related errors
```

### 2. Test Collection Creation

1. Create manual collection for a location
2. Add machines to collection
3. Test collection filtering
4. Generate auto-collections

### 3. Test Collection Types

1. Enable/disable collection types
2. Test auto-generation
3. Verify organization isolation

### 4. Test Public Collection API

1. Get collections for location
2. Filter machines by collection
3. Test collection visibility

## Progress Notes

### Implementation Decisions Made:

- Separated manual and auto-generated collections
- Used flexible filterCriteria JSON for auto-collections
- Implemented organization-wide and location-specific collections
- Added collection type management for admin control

### Database Changes:

- Enhanced Collection model with manual/auto flags
- Added CollectionType model for organization configuration
- Implemented many-to-many Machine-Collection relationship
- Added proper indexing for performance

### Service Architecture:

- Centralized CollectionService for all collection operations
- Auto-generation system for manufacturer and era collections
- Public API for location filtering
- Admin API for collection management

## Rollback Procedure

```bash
# Restore schema
git checkout HEAD -- prisma/schema.prisma

# Remove collection files
rm src/server/services/collectionService.ts
rm src/server/api/routers/collection.ts

# Reset database
npm run db:reset
```
