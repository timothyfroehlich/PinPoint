/**
 * Shared Seeded TRPC Context Helper for Collection Tests
 *
 * Creates standardized TRPC context for collection-related integration tests.
 * Uses seeded test data to ensure consistent relationships and reduce
 * duplicated context construction logic across tests.
 *
 * Key Features:
 * - Uses seeded test data from getSeededTestData()
 * - Standardized service mocks for collection operations
 * - Proper organizational scoping
 * - Real membership relationships
 * - Consistent user permissions for collection operations
 */

import { eq, and } from "drizzle-orm";
import { vi } from "vitest";
import { type TestDatabase } from "~/test/helpers/pglite-test-setup";
import { memberships, roles, organizations } from "~/server/db/schema";
import { generateTestId } from "~/test/helpers/test-id-generator";

export interface SeededCollectionTestContext {
  db: TestDatabase;
  user: {
    id: string;
    email: string;
    user_metadata: { name: string };
    app_metadata: { organization_id: string };
  };
  organization: {
    id: string;
    name: string;
    subdomain: string;
  };
  membership?: any; // Real membership from database
  session: {
    user: {
      id: string;
      email: string;
      name: string;
      image: null;
    };
    expires: string;
  };
  services: {
    createCollectionService: any;
    createNotificationService: any;
    createIssueActivityService: any;
    createCommentCleanupService?: any;
  };
  headers: Headers;
  userPermissions: string[];
  supabase: any; // Mocked Supabase client
  logger: any; // Mocked logger
}

export interface SeededCollectionTestOptions {
  permissions?: string[]; // Override default permissions
}

/**
 * Creates standardized TRPC context for collection-related tests using seeded data
 *
 * @param txDb - Transaction database instance
 * @param organizationId - Organization ID (typically from SEED_TEST_IDS.ORGANIZATIONS)
 * @param userId - User ID (typically from seeded test data)
 * @param options - Optional configuration for permissions and other settings
 * @returns Standardized test context for TRPC collection procedures
 */
/**
 * Creates public test context (no authentication) for public procedures
 *
 * @param txDb - Transaction database instance
 * @param organizationId - Organization ID for organizational scoping
 * @returns Public test context for TRPC procedures
 */
export async function createPublicTestContext(
  txDb: TestDatabase,
  organizationId: string,
): Promise<SeededCollectionTestContext> {
  // Query organization data to match public procedure context contract
  // Public procedures provide organization via subdomain fallback
  const org = await txDb.query.organizations.findFirst({
    where: eq(organizations.id, organizationId),
  });

  if (!org) {
    throw new Error(
      `Organization ${organizationId} not found in test database`,
    );
  }

  // Create standardized service mocks for collection operations
  const services = {
    createCollectionService: vi.fn(() => ({
      getLocationCollections: vi.fn((locationId: string) =>
        Promise.resolve({
          manual: [
            {
              id: "test-collection-1",
              name: "Test Manual Collection",
              type: {
                id: "test-type-1",
                name: "Rooms",
                displayName: "Rooms",
                isEnabled: true,
                isAutoGenerated: false,
              },
              locationId,
              organizationId,
              isManual: true,
            },
          ],
          auto: [],
        }),
      ),
      getCollectionMachines: vi.fn((collectionId: string) =>
        Promise.resolve([
          {
            id: "test-machine-1",
            name: "Test Machine 1",
            model: {
              id: "test-model-1",
              name: "Test Model",
              manufacturer: "Test Manufacturer",
              year: 2024,
            },
            collectionId,
          },
        ]),
      ),
    })),
    createNotificationService: vi.fn(() => ({})),
    createIssueActivityService: vi.fn(() => ({})),
    createCommentCleanupService: vi.fn(() => ({})),
  };

  // Mock logger with all required methods
  const logger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    trace: vi.fn(),
    child: vi.fn().mockReturnThis(),
    withRequest: vi.fn().mockReturnThis(),
    withUser: vi.fn().mockReturnThis(),
    withOrganization: vi.fn().mockReturnThis(),
    withContext: vi.fn().mockReturnThis(),
  };

  return {
    db: txDb,
    user: null, // No user for public procedures
    organizationId, // Public procedures can have organizationId via subdomain
    organization: {
      id: org.id,
      name: org.name,
      subdomain: org.subdomain,
    }, // Organization provided via subdomain fallback
    membership: undefined,
    session: {
      user: {
        id: "anonymous",
        email: "anonymous@example.com",
        name: "Anonymous User",
        image: null,
      },
      expires: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(),
    },
    services,
    headers: new Headers(),
    userPermissions: [], // No permissions for public procedures
    supabase: null, // No Supabase client for public procedures
    logger,
  };
}

export async function createSeededCollectionTestContext(
  txDb: TestDatabase,
  organizationId: string,
  userId: string,
  options: SeededCollectionTestOptions = {},
): Promise<SeededCollectionTestContext> {
  // Validate required seeded data exists
  if (!organizationId || !userId) {
    throw new Error(
      "createSeededCollectionTestContext requires valid organizationId and userId from seeded data",
    );
  }

  // Query real membership from database for integration tests
  let membership = await txDb.query.memberships.findFirst({
    where: and(
      eq(memberships.userId, userId),
      eq(memberships.organizationId, organizationId),
    ),
    with: {
      role: {
        with: {
          permissions: true,
        },
      },
    },
  });

  // If membership doesn't exist, create one within the transaction for testing
  if (!membership) {
    console.warn(
      `Creating membership for userId ${userId} in organizationId ${organizationId} within test transaction`,
    );

    // Find existing Member role or create one
    let memberRole = await txDb.query.roles.findFirst({
      where: and(
        eq(roles.organizationId, organizationId),
        eq(roles.name, "Member"),
      ),
    });

    if (!memberRole) {
      // Create a minimal Member role for testing
      const [createdRole] = await txDb
        .insert(roles)
        .values({
          id: generateTestId("test-member-role"),
          name: "Member",
          organizationId,
          isDefault: true,
          isSystem: false,
          createdAt: new Date(),
          updatedAt: new Date(),
        })
        .returning();
      memberRole = createdRole;
    }

    // Create the membership
    const [createdMembership] = await txDb
      .insert(memberships)
      .values({
        id: generateTestId("test-membership"),
        userId,
        organizationId,
        roleId: memberRole.id,
      })
      .returning();

    // Query the full membership with role and permissions
    membership = await txDb.query.memberships.findFirst({
      where: eq(memberships.id, createdMembership.id),
      with: {
        role: {
          with: {
            permissions: true,
          },
        },
      },
    });
  }

  // Create standardized service mocks for collection operations
  const services = {
    createCollectionService: vi.fn(() => ({
      getLocationCollections: vi.fn((locationId: string) =>
        Promise.resolve({
          manual: [
            {
              id: "test-collection-1",
              name: "Test Manual Collection",
              type: "manual",
              locationId,
              organizationId,
              machines: [
                {
                  id: "test-machine-1",
                  name: "Test Machine 1",
                  model: "Test Model",
                },
              ],
            },
          ],
          auto: [
            {
              id: "test-collection-2",
              name: "Test Auto Collection",
              type: "auto",
              locationId,
              organizationId,
              machines: [
                {
                  id: "test-machine-2",
                  name: "Test Machine 2",
                  model: "Test Model 2",
                },
              ],
            },
          ],
        }),
      ),
      getCollectionMachines: vi.fn((collectionId: string) =>
        Promise.resolve([
          {
            id: "test-machine-1",
            name: "Test Machine 1",
            model: "Test Model",
            collectionId,
          },
        ]),
      ),
      createManualCollection: vi.fn(async (data: any) => {
        // Validation
        if (!data.name || !data.typeId) {
          throw new Error("Name and type ID are required");
        }

        // Return created collection
        return {
          id: "new-collection-id",
          name: data.name,
          typeId: data.typeId,
          locationId: data.locationId,
          isManual: true,
        };
      }),
      addMachinesToCollection: vi.fn(async (data: any) => {
        // Return success response (validation handled at tRPC level)
        return { success: true, added: data.machineIds?.length || 0 };
      }),
      generateAutoCollections: vi.fn(async () => {
        // Return array directly as expected by tests
        return [
          { id: "auto-collection-1", name: "Auto Collection 1" },
          { id: "auto-collection-2", name: "Auto Collection 2" },
        ];
      }),
      getOrganizationCollectionTypes: vi.fn(async () => {
        return [
          {
            id: "type-1",
            name: "Rooms",
            displayName: "Rooms",
            isEnabled: true,
            isAutoGenerated: false,
          },
          {
            id: "type-2",
            name: "Manufacturer",
            displayName: "Manufacturer",
            isEnabled: true,
            isAutoGenerated: true,
          },
        ];
      }),
      toggleCollectionType: vi.fn(async (typeId: string, enabled: boolean) => {
        // Return the new enabled state (validation handled at tRPC level)
        return { success: true, enabled: enabled };
      }),
    })),
    createNotificationService: vi.fn(() => ({
      notifyCollectionCreated: vi.fn(),
      notifyCollectionUpdated: vi.fn(),
    })),
    createIssueActivityService: vi.fn(() => ({
      recordCollectionChange: vi.fn(),
    })),
    createCommentCleanupService: vi.fn(() => ({
      getCleanupStats: vi.fn(),
      performCleanup: vi.fn(),
    })),
  };

  // Mock Supabase client
  const supabase = {
    auth: {
      getUser: vi.fn().mockResolvedValue({
        data: {
          user: {
            id: userId,
            email: "test@example.com",
            user_metadata: { name: "Test User" },
            app_metadata: { organization_id: organizationId },
          },
        },
        error: null,
      }),
    },
  };

  // Mock logger with all required methods
  const logger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    trace: vi.fn(),
    child: vi.fn().mockReturnThis(),
    withRequest: vi.fn().mockReturnThis(),
    withUser: vi.fn().mockReturnThis(),
    withOrganization: vi.fn().mockReturnThis(),
    withContext: vi.fn().mockReturnThis(),
  };

  // Minimal default permissions - tests should explicitly request needed permissions
  const defaultPermissions = [
    "collection:view",
    "location:view",
    "machine:view",
  ];

  return {
    db: txDb,
    user: {
      id: userId,
      email: "test@example.com",
      user_metadata: { name: "Test User" },
      app_metadata: { organization_id: organizationId },
    },
    organization: {
      id: organizationId,
      name: "Test Organization",
      subdomain: "test-org",
    },
    membership,
    session: {
      user: {
        id: userId,
        email: "test@example.com",
        name: "Test User",
        image: null,
      },
      expires: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(),
    },
    services,
    headers: new Headers(),
    userPermissions: options.permissions || defaultPermissions,
    supabase,
    logger,
  };
}
