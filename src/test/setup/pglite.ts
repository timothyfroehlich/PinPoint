/**
 * Worker-Scoped PGlite Setup
 *
 * CRITICAL: Per CORE-TEST-001, we use ONE worker-scoped PGlite instance
 * for all tests in a worker. Per-test instances cause system lockups.
 *
 * Schema (schema.sql) is auto-generated from src/server/db/schema.ts and NOT committed.
 * Run `pnpm run test:ensure-schema` to regenerate if missing or stale.
 */

import { readFileSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { PGlite } from "@electric-sql/pglite";
import { citext } from "@electric-sql/pglite/contrib/citext";
import type { PgliteDatabase } from "drizzle-orm/pglite";
import { drizzle } from "drizzle-orm/pglite";
import { beforeAll, afterEach } from "vitest";
import * as schema from "~/server/db/schema";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Worker-scoped instance - created once per worker
let pgliteInstance: PGlite | undefined;
let testDb: PgliteDatabase<typeof schema> | undefined;

/**
 * Get the worker-scoped test database instance.
 * Creates and initializes on first call, returns cached instance thereafter.
 */
export async function getTestDb(): Promise<PgliteDatabase<typeof schema>> {
  if (testDb) {
    return testDb;
  }

  // Create PGlite instance with citext extension for case-insensitive email columns
  pgliteInstance = new PGlite({ extensions: { citext } });

  // Create Drizzle instance
  testDb = drizzle(pgliteInstance, { schema });

  // Create auth schema for tests (required for auth.users table)
  await pgliteInstance.exec('CREATE SCHEMA IF NOT EXISTS "auth";');

  // Enable citext extension (required for case-insensitive email columns)
  await pgliteInstance.exec('CREATE EXTENSION IF NOT EXISTS "citext";');

  // Load schema SQL generated by drizzle-kit export
  // This ensures test schema matches production schema exactly
  const schemaPath = join(__dirname, "schema.sql");
  const schemaSql = readFileSync(schemaPath, "utf-8");

  // Apply schema (create tables and constraints)
  await pgliteInstance.exec(schemaSql);

  return testDb;
}

/**
 * Clean up helper - deletes all rows from all tables.
 * Use in afterEach to ensure test isolation.
 */
export async function cleanupTestDb() {
  if (!testDb) return;

  // Delete in order to respect foreign key constraints
  await testDb.delete(schema.issueWatchers);
  await testDb.delete(schema.issueImages); // Added
  await testDb.delete(schema.issueComments);
  await testDb.delete(schema.issues);
  await testDb.delete(schema.machines);
  await testDb.delete(schema.userProfiles);
  await testDb.delete(schema.invitedUsers);
  await testDb.delete(schema.authUsers);
}

/**
 * Setup function for integration tests.
 * Call this in describe blocks that need database access.
 */
export function setupTestDb() {
  beforeAll(async () => {
    await getTestDb();
  });

  afterEach(async () => {
    await cleanupTestDb();
  });
}
