import { beforeEach, describe, expect, it, vi } from "vitest";

import type { ExtendedPrismaClient } from "~/server/db";

import { CollectionService } from "~/server/services/collectionService";

// Simple integration test focusing on service integration with router input validation
describe("Collection Router Integration", () => {
  let service: CollectionService;
  let mockPrisma: ExtendedPrismaClient;

  beforeEach(() => {
    mockPrisma = {
      collectionType: {
        findMany: vi.fn(),
        update: vi.fn(),
      },
      collection: {
        findMany: vi.fn(),
        findFirst: vi.fn(),
        create: vi.fn(),
        update: vi.fn(),
      },
      machine: {
        findMany: vi.fn(),
      },
      $accelerate: {
        invalidate: vi.fn(),
        ttl: vi.fn(),
      },
    } as unknown as ExtendedPrismaClient;

    service = new CollectionService(mockPrisma);
    vi.clearAllMocks();
  });

  describe("Input validation and service integration", () => {
    it("should handle getLocationCollections input validation", async () => {
      const mockTypes = [
        {
          id: "type1",
          name: "Rooms",
          displayName: "Rooms",
          isEnabled: true,
          sortOrder: 1,
        },
      ];

      const mockCollections = [
        {
          id: "coll1",
          name: "Front Room",
          isManual: true,
          type: mockTypes[0],
          _count: { machines: 5 },
        },
      ];

      vi.mocked(mockPrisma.collectionType.findMany).mockResolvedValue(
        mockTypes as any,
      );
      vi.mocked(mockPrisma.collection.findMany).mockResolvedValue(
        mockCollections as any,
      );

      const result = await service.getLocationCollections(
        "valid-loc-id",
        "valid-org-id",
      );

      expect(result).toHaveProperty("manual");
      expect(result).toHaveProperty("auto");
      expect(mockPrisma.collection.findMany).toHaveBeenCalledWith({
        where: {
          OR: [
            { locationId: "valid-loc-id" },
            { locationId: null, isManual: false },
          ],
          type: {
            organizationId: "valid-org-id",
            isEnabled: true,
          },
        },
        include: {
          type: {
            select: {
              id: true,
              name: true,
              displayName: true,
            },
          },
          _count: {
            select: {
              machines: {
                where: {
                  locationId: "valid-loc-id",
                },
              },
            },
          },
        },
        orderBy: [
          {
            type: {
              sortOrder: "asc",
            },
          },
          {
            sortOrder: "asc",
          },
        ],
      });
    });

    it("should handle createManualCollection input validation", async () => {
      const mockCollection = {
        id: "coll1",
        name: "Test Collection",
        typeId: "type1",
        locationId: "loc1",
        isManual: true,
      };

      vi.mocked(mockPrisma.collection.create).mockResolvedValue(
        mockCollection as any,
      );

      const result = await service.createManualCollection("org1", {
        name: "Test Collection",
        typeId: "type1",
        locationId: "loc1",
        description: "Test description",
      });

      expect(result).toEqual(mockCollection);
      expect(mockPrisma.collection.create).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            name: "Test Collection",
            typeId: "type1",
            locationId: "loc1",
            description: "Test description",
            organizationId: "org1",
            isManual: true,
            isSmart: false,
          }),
        }),
      );
    });

    it("should handle toggleCollectionType operations", async () => {
      vi.mocked(mockPrisma.collectionType.update).mockResolvedValue({} as any);

      await service.toggleCollectionType("type1", false);

      expect(mockPrisma.collectionType.update).toHaveBeenCalledWith({
        where: { id: "type1" },
        data: { isEnabled: false },
      });
    });

    it("should validate organization collection types query", async () => {
      const mockTypes = [
        {
          id: "type1",
          name: "Rooms",
          displayName: "Rooms",
          isAutoGenerated: false,
          isEnabled: true,
          _count: { collections: 3 },
        },
      ];

      vi.mocked(mockPrisma.collectionType.findMany).mockResolvedValue(
        mockTypes as any,
      );

      const result = await service.getOrganizationCollectionTypes("org1");

      expect(result).toEqual([
        {
          id: "type1",
          name: "Rooms",
          displayName: "Rooms",
          isAutoGenerated: false,
          isEnabled: true,
          _count: { collections: 3 },
          collectionCount: 3,
        },
      ]);
    });
  });
});
