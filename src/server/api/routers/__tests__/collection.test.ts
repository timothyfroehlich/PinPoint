/* eslint-disable @typescript-eslint/no-explicit-any */
import { beforeEach, describe, expect, it, jest } from "@jest/globals";

import type { ExtendedPrismaClient } from "~/server/db";

import { CollectionService } from "~/server/services/collectionService";

// Simple integration test focusing on service integration with router input validation
describe("Collection Router Integration", () => {
  let service: CollectionService;
  let mockPrisma: jest.Mocked<ExtendedPrismaClient>;

  beforeEach(() => {
    mockPrisma = {
      collectionType: {
        findMany: jest.fn(),
        update: jest.fn(),
      },
      collection: {
        findMany: jest.fn(),
        findFirst: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
      },
      machine: {
        findMany: jest.fn(),
      },
      $accelerate: {
        invalidate: jest.fn(),
        ttl: jest.fn(),
      },
    } as unknown as jest.Mocked<ExtendedPrismaClient>;

    service = new CollectionService(mockPrisma);
    jest.clearAllMocks();
  });

  describe("Input validation and service integration", () => {
    it("should handle getLocationCollections input validation", async () => {
      const mockTypes = [
        {
          id: "type1",
          name: "Rooms",
          displayName: "Rooms",
          isEnabled: true,
          sortOrder: 1,
        },
      ];

      const mockCollections = [
        {
          id: "coll1",
          name: "Front Room",
          isManual: true,
          type: mockTypes[0],
          _count: { machines: 5 },
        },
      ];

      (mockPrisma.collectionType.findMany as jest.Mock<any>).mockImplementation(
        () => Promise.resolve(mockTypes),
      );
      (mockPrisma.collection.findMany as jest.Mock<any>).mockImplementation(
        () => Promise.resolve(mockCollections),
      );

      const result = await service.getLocationCollections(
        "valid-loc-id",
        "valid-org-id",
      );

      expect(result).toHaveProperty("manual");
      expect(result).toHaveProperty("auto");
      expect(mockPrisma.collection.findMany).toHaveBeenCalledWith({
        where: {
          OR: [
            { locationId: "valid-loc-id" },
            { locationId: null, isManual: false },
          ],
          type: {
            organizationId: "valid-org-id",
            isEnabled: true,
          },
        },
        include: {
          type: {
            select: {
              id: true,
              name: true,
              displayName: true,
            },
          },
          _count: {
            select: {
              machines: {
                where: {
                  locationId: "valid-loc-id",
                },
              },
            },
          },
        },
        orderBy: [
          {
            type: {
              sortOrder: "asc",
            },
          },
          {
            sortOrder: "asc",
          },
        ],
      });
    });

    it("should handle createManualCollection input validation", async () => {
      const mockCollection = {
        id: "coll1",
        name: "Test Collection",
        typeId: "type1",
        locationId: "loc1",
        isManual: true,
      };

      (mockPrisma.collection.create as jest.Mock<any>).mockImplementation(() =>
        Promise.resolve(mockCollection),
      );

      const result = await service.createManualCollection({
        name: "Test Collection",
        typeId: "type1",
        locationId: "loc1",
        description: "Test description",
      });

      expect(result).toEqual(mockCollection);
      expect(mockPrisma.collection.create).toHaveBeenCalledWith({
        data: {
          name: "Test Collection",
          typeId: "type1",
          locationId: "loc1",
          description: "Test description",
          isManual: true,
          isSmart: false,
        },
      });
    });

    it("should handle toggleCollectionType operations", async () => {
      (mockPrisma.collectionType.update as jest.Mock<any>).mockImplementation(
        () => Promise.resolve({}),
      );

      await service.toggleCollectionType("type1", false);

      expect(mockPrisma.collectionType.update).toHaveBeenCalledWith({
        where: { id: "type1" },
        data: { isEnabled: false },
      });
    });

    it("should validate organization collection types query", async () => {
      const mockTypes = [
        {
          id: "type1",
          name: "Rooms",
          displayName: "Rooms",
          isAutoGenerated: false,
          isEnabled: true,
          _count: { collections: 3 },
        },
      ];

      (mockPrisma.collectionType.findMany as jest.Mock<any>).mockImplementation(
        () => Promise.resolve(mockTypes),
      );

      const result = await service.getOrganizationCollectionTypes("org1");

      expect(result).toEqual([
        {
          id: "type1",
          name: "Rooms",
          displayName: "Rooms",
          isAutoGenerated: false,
          isEnabled: true,
          _count: { collections: 3 },
          collectionCount: 3,
        },
      ]);
    });
  });
});
