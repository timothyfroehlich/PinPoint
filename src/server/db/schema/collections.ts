import {
  pgTable,
  text,
  timestamp,
  boolean,
  integer,
  pgEnum,
  json,
  index,
  primaryKey,
} from "drizzle-orm/pg-core";

// =================================
// ENUMS
// =================================

export const notificationTypeEnum = pgEnum("notification_type", [
  "ISSUE_CREATED", // New issue on owned machine
  "ISSUE_UPDATED", // Issue status changed
  "ISSUE_ASSIGNED", // Issue assigned to user
  "ISSUE_COMMENTED", // New comment on issue
  "MACHINE_ASSIGNED", // Machine ownership assigned
  "SYSTEM_ANNOUNCEMENT", // System-wide announcements
]);

export const notificationEntityEnum = pgEnum("notification_entity", [
  "ISSUE",
  "MACHINE",
  "COMMENT",
  "ORGANIZATION",
]);

// =================================
// COLLECTION & NOTIFICATION TABLES
// =================================

export const collections = pgTable(
  "collections",
  {
    id: text().primaryKey(),
    name: text().notNull(), // e.g., "Front Room", "Bally", "1980s"
    typeId: text().notNull(),
    locationId: text(), // null for auto-collections (organization-wide)
    organizationId: text().notNull(), // Multi-tenant support
    isSmart: boolean().default(false).notNull(), // For 1.x Smart Collections
    isManual: boolean().default(true).notNull(), // Manual vs auto-generated

    // Manual collection fields
    description: text(), // Optional description
    sortOrder: integer().default(0).notNull(), // For custom ordering

    // Auto-collection fields
    filterCriteria: json(), // Criteria for auto-collections: { "manufacturer": "Bally" }

    // Timestamps
    createdAt: timestamp().defaultNow().notNull(),
    updatedAt: timestamp().defaultNow().notNull(),
  },
  (table) => [
    // Multi-tenancy: organizationId filtering (critical)
    index("collections_organization_id_idx").on(table.organizationId),
    // Collection filtering by type
    index("collections_type_id_idx").on(table.typeId),
    // Location-specific filtering
    index("collections_location_id_idx").on(table.locationId),
  ],
);

// locationId is nullable for organization-wide collections

export const collectionTypes = pgTable(
  "collection_types",
  {
    id: text().primaryKey(),
    name: text().notNull(), // e.g., "Rooms", "Manufacturer", "Era", "Genre"
    organizationId: text().notNull(),
    isAutoGenerated: boolean().default(false).notNull(), // Auto vs manual collection type
    isEnabled: boolean().default(true).notNull(), // Can be disabled in org settings

    // Auto-generation settings
    sourceField: text(), // Field to generate from: "manufacturer", "year", etc.
    generationRules: json(), // Rules for auto-generation

    // Display settings
    displayName: text(), // Human-readable name for UI
    description: text(), // Description for admin interface
    sortOrder: integer().default(0).notNull(), // Order on location pages

    // Timestamps
    createdAt: timestamp().defaultNow().notNull(),
    updatedAt: timestamp().defaultNow().notNull(),
  },
  (table) => [
    // Multi-tenancy: organizationId filtering (most critical)
    index("collection_types_organization_id_idx").on(table.organizationId),
    // Collection type filtering and display ordering
    index("collection_types_is_enabled_idx").on(table.isEnabled),
    index("collection_types_sort_order_idx").on(table.sortOrder),
  ],
);

export const notifications = pgTable(
  "notifications",
  {
    id: text().primaryKey(),
    message: text().notNull(),
    read: boolean().default(false).notNull(),
    createdAt: timestamp().defaultNow().notNull(),

    // Enhanced fields
    userId: text().notNull(), // Who receives this notification
    type: notificationTypeEnum().notNull(), // Category of notification
    entityType: notificationEntityEnum(), // What kind of entity (issue, machine, etc.)
    entityId: text(), // ID of the related entity
    actionUrl: text(), // URL to navigate to when clicked

    // RLS organizational scoping
    organizationId: text().notNull(), // Set automatically by trigger
  },
  (table) => [
    // Essential notification indexes for performance
    index("notifications_user_id_read_idx").on(table.userId, table.read),
    index("notifications_user_id_created_at_idx").on(
      table.userId,
      table.createdAt,
    ),
    // RLS organizational index (matches setup-rls.sql)
    index("notifications_organization_id_idx").on(table.organizationId),
  ],
);

export const collectionMachines = pgTable(
  "collection_machines",
  {
    collectionId: text().notNull(),
    machineId: text().notNull(),
    createdAt: timestamp().defaultNow().notNull(),
  },
  (table) => [
    // Composite primary key
    primaryKey({ columns: [table.collectionId, table.machineId] }),
    // Indexes for efficient lookups
    index("collection_machines_collection_id_idx").on(table.collectionId),
    index("collection_machines_machine_id_idx").on(table.machineId),
  ],
);

export const pinballMapConfigs = pgTable(
  "pinball_map_configs",
  {
    id: text().primaryKey(),
    organizationId: text().unique().notNull(),

    // API Configuration
    apiEnabled: boolean().default(false).notNull(),
    apiKey: text(), // If PinballMap requires API key in future

    // Sync Settings
    autoSyncEnabled: boolean().default(false).notNull(),
    syncIntervalHours: integer().default(24).notNull(),
    lastGlobalSync: timestamp(),

    // Data Preferences
    createMissingModels: boolean().default(true).notNull(), // Create Model records for unknown OPDB games
    updateExistingData: boolean().default(false).notNull(), // Whether to update existing machine data
  },
  (table) => [
    // PinballMap config lookup (already has unique constraint but adding explicit index)
    index("pinball_map_configs_organization_id_idx").on(table.organizationId),
  ],
);
