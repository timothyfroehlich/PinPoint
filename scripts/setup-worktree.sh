#!/bin/bash
set -e

# Check for overwrite flag
OVERWRITE=false
if [[ "$1" == "--overwrite" ]]; then
    OVERWRITE=true
fi

# Calculate unique ports for this worktree to prevent conflicts
WORKTREE_HASH=$(echo "$(pwd)" | md5sum | cut -c1-4)
PORT_OFFSET=$((0x$WORKTREE_HASH % 100))
BASE_PORT=$((54320 + $PORT_OFFSET))
API_PORT=$((BASE_PORT + 1))    # e.g., 54321
DB_PORT=$((BASE_PORT + 2))     # e.g., 54322  
STUDIO_PORT=$((BASE_PORT + 3)) # e.g., 54323
INBUCKET_PORT=$((BASE_PORT + 4)) # e.g., 54324

echo "ðŸ”§ Worktree Setup - Unique Ports:"
echo "   API: $API_PORT | DB: $DB_PORT | Studio: $STUDIO_PORT | Email: $INBUCKET_PORT"

# Safety check: warn if running from main repository
if [ "$(git rev-parse --git-dir)" = "$(git rev-parse --git-common-dir)" ]; then
    echo "âš ï¸  Warning: This script is designed for Git worktrees."
    echo "   You appear to be in the main repository."
    echo "   Running this may overwrite your .env.local and affect your main development setup."
    echo ""
    read -p "Continue anyway? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

# Check if .env exists and exit unless overwrite
if [[ -f .env && "$OVERWRITE" == "false" ]]; then
    echo ".env already exists. Use --overwrite flag to replace it."
    exit 1
fi

# Copy Vercel project configuration from main worktree
MAIN_WORKTREE=$(git worktree list --porcelain | awk '/^worktree/ {print $2; exit}')
if [[ -d "$MAIN_WORKTREE/.vercel" ]]; then
    echo "Copying Vercel project configuration..."
    cp -r "$MAIN_WORKTREE/.vercel" .
else
    echo "No .vercel directory found in main worktree. Linking to Vercel project..."
    vercel link --yes --project pin-point --scope advacar

    # Now copy the newly created .vercel config to main worktree for future use
    if [[ -d ".vercel" && "$MAIN_WORKTREE" != "$(pwd)" ]]; then
        echo "Copying Vercel config back to main worktree for future worktrees..."
        cp -r .vercel "$MAIN_WORKTREE/"
    fi
fi

# Pull environment variables from Vercel
echo "ðŸ“¥ Pulling environment variables from Vercel..."
vercel env pull .env

# Update environment variables with worktree-specific ports
echo "âš™ï¸  Updating environment variables with unique ports..."
cat >> .env << EOF

# Worktree-specific port configuration (auto-generated)
NEXT_PUBLIC_SUPABASE_URL=http://localhost:$API_PORT
SUPABASE_API_URL=http://localhost:$API_PORT
DATABASE_URL=postgresql://postgres:postgres@localhost:$DB_PORT/postgres
DIRECT_URL=postgresql://postgres:postgres@localhost:$DB_PORT/postgres
EOF

# Create symlink for .env.local (remove existing first)
rm -f .env.local
ln -sf .env .env.local

echo "âœ… Environment configured with unique ports for this worktree"

# Install and setup
npm install

# Initialize Supabase configuration with worktree-specific ports
echo "ðŸš€ Initializing Supabase configuration..."
if command -v supabase &> /dev/null; then
    if [ ! -f "supabase/config.toml" ]; then
        npx supabase init --create-project false
        echo "âœ… Supabase initialized for worktree."
    else
        echo "â„¹ï¸  Supabase already initialized (config.toml exists)."
    fi
    
    # Create optimized config.toml with unique ports and performance optimizations
    echo "âš™ï¸  Configuring optimized Supabase settings..."
    cat > supabase/config.toml << EOF
# Worktree-specific Supabase configuration
# Auto-generated by setup-worktree.sh with unique ports

[api]
enabled = true
port = $API_PORT
schemas = ["public", "graphql_public"]
extra_search_path = ["public", "extensions"]
max_rows = 1000

[db]
port = $DB_PORT
shadow_port = $((DB_PORT - 2))
major_version = 17

[db.pooler]
enabled = false

[db.migrations]
# Disabled during development phase for performance
enabled = false
schema_paths = []

[db.seed]
enabled = true
sql_paths = ["./seed.sql"]

[realtime]
# Disabled for performance during development
enabled = false

[studio]
# Disabled for performance during development  
enabled = false
port = $STUDIO_PORT

[inbucket]
enabled = true
port = $INBUCKET_PORT

[storage]
enabled = true
file_size_limit = "50MiB"

[auth]
enabled = true
site_url = "http://127.0.0.1:3000"
additional_redirect_urls = ["https://127.0.0.1:3000"]
jwt_expiry = 3600
enable_refresh_token_rotation = true
refresh_token_reuse_interval = 10
enable_signup = true
enable_anonymous_sign_ins = false
minimum_password_length = 6

[auth.email]
enable_signup = true
double_confirm_changes = true
enable_confirmations = false
secure_password_change = false
max_frequency = "1s"
otp_length = 6
otp_expiry = 3600

[edge_runtime]
enabled = true
policy = "oneshot"
inspector_port = $((API_PORT + 100))
deno_version = 1

[analytics]
enabled = true
port = $((API_PORT + 200))
backend = "postgres"
EOF

    echo "âœ… Supabase config optimized with ports API:$API_PORT DB:$DB_PORT"
else
    echo "âš ï¸  Warning: Supabase CLI not found. Install with 'npm install -g supabase' if needed."
fi

# Set up database schema (using shared online database)
echo "Setting up database schema..."
if npm run db:push 2>/dev/null; then
    echo "Database schema synced successfully."
    
    # Generate Prisma client types
    echo "Generating Prisma client types..."
    if npx prisma generate 2>/dev/null; then
        echo "Prisma client types generated successfully."
    else
        echo "Warning: Could not generate Prisma client types."
        echo "Run 'npx prisma generate' manually if needed."
    fi
else
    echo "Warning: Could not sync database schema."
    echo "Check your database connection and run 'npm run db:push' manually."
fi

# Health check function
check_service_health() {
    echo "ðŸ” Performing service health checks..."
    
    # Check if Supabase is running on expected ports
    if curl -f -s "http://localhost:$API_PORT/health" > /dev/null 2>&1; then
        echo "âœ… Supabase API (port $API_PORT): Healthy"
    else
        echo "âš ï¸  Supabase API (port $API_PORT): Not responding (run 'supabase start' if needed)"
    fi
    
    # Check database connectivity
    if command -v pg_isready &> /dev/null; then
        if pg_isready -p $DB_PORT -h localhost > /dev/null 2>&1; then
            echo "âœ… PostgreSQL (port $DB_PORT): Healthy" 
        else
            echo "âš ï¸  PostgreSQL (port $DB_PORT): Not responding"
        fi
    else
        echo "â„¹ï¸  PostgreSQL check skipped (pg_isready not available)"
    fi
    
    # Create port info file for reference
    cat > .worktree-ports << EOF
# Worktree Port Configuration
# Generated: $(date)
API_PORT=$API_PORT
DB_PORT=$DB_PORT
STUDIO_PORT=$STUDIO_PORT
INBUCKET_PORT=$INBUCKET_PORT
WORKTREE_HASH=$WORKTREE_HASH
EOF
}

# Run health checks
check_service_health

echo ""
echo "ðŸŽ‰ Worktree setup complete!"
echo "ðŸ“ Ports: API($API_PORT) DB($DB_PORT) Studio($STUDIO_PORT) Email($INBUCKET_PORT)"
echo "ðŸ’¡ Run './scripts/worktree-status.sh' to check environment health anytime"