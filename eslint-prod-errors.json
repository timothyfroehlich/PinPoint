[
  {
    "filePath": "/home/froeht/Code/PinPoint/src/__mocks__/next-auth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/__mocks__/next-auth/react.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/_components/AuthenticatedLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/_components/DevLoginCompact.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/_components/LoginModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/auth/[...nextauth]/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/dev/users/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/health/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/qr/[qrCodeId]/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/trpc/[trpc]/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/upload/issue/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/upload/organization-logo/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/api/upload/route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/dashboard/_components/DetailedIssueCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/dashboard/_components/PrimaryAppBar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/dashboard/_components/SecondaryHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/dashboard/layout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/dashboard/page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/layout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/providers.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/app/theme.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/image-storage/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/image-storage/local-storage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/opdb/client.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/opdb/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/opdb/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/opdb/utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/pinballmap/client.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/pinballmap/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/types/gameInstance.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/lib/utils/image-processing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/root.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/collection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/comment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.admin.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.attachment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.comment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.core.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.status.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 1,
        "message": "Unsafe argument of type error typed assigned to a parameter of type `string`.",
        "line": 33,
        "column": 38,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 33,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access ._all on an `error` typed value.",
        "line": 35,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 35,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { StatusCategory } from \"@prisma/client\";\n\nimport { createTRPCRouter, organizationProcedure } from \"~/server/api/trpc\";\n\nexport const issueStatusRouter = createTRPCRouter({\n  // Get counts for each status category\n  getStatusCounts: organizationProcedure.query(async ({ ctx }) => {\n    const counts = await ctx.db.issue.groupBy({\n      by: [\"statusId\"],\n      where: {\n        organizationId: ctx.organization.id,\n      },\n      _count: {\n        _all: true,\n      },\n    });\n\n    const statuses = await ctx.db.issueStatus.findMany({\n      where: {\n        organizationId: ctx.organization.id,\n      },\n    });\n\n    const statusMap = new Map(statuses.map((s) => [s.id, s.category]));\n\n    const categoryCounts = {\n      [StatusCategory.NEW]: 0,\n      [StatusCategory.IN_PROGRESS]: 0,\n      [StatusCategory.RESOLVED]: 0,\n    };\n\n    for (const group of counts) {\n      const category = statusMap.get(group.statusId);\n      if (category) {\n        categoryCounts[category] += Number(group._count._all);\n      }\n    }\n\n    return categoryCounts;\n  }),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.timeline.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/issueStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/location.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/machine.core.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/machine.location.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/machine.owner.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/machine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/model.core.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/model.opdb.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"number\" of template literal expression.",
        "line": 108,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 108,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"number\" of template literal expression.",
        "line": 108,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 108,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from \"zod\";\n\nimport { env } from \"~/env\";\nimport { OPDBClient } from \"~/lib/opdb/client\";\nimport {\n  createTRPCRouter,\n  organizationProcedure,\n  organizationManageProcedure,\n} from \"~/server/api/trpc\";\n\nexport const modelOpdbRouter = createTRPCRouter({\n  // Search OPDB games for typeahead\n  searchOPDB: organizationProcedure\n    .input(z.object({ query: z.string().min(1) }))\n    .query(async ({ input }) => {\n      const opdbClient = new OPDBClient(env.OPDB_API_KEY, env.OPDB_API_URL);\n      return await opdbClient.searchMachines(input.query);\n    }),\n\n  // Create Model from OPDB data\n  createFromOPDB: organizationManageProcedure\n    .input(z.object({ opdbId: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      // Check if this OPDB game already exists globally\n      const existingGame = await ctx.db.model.findUnique({\n        where: {\n          opdbId: input.opdbId,\n        },\n      });\n\n      if (existingGame) {\n        throw new Error(\"This game already exists in the system\");\n      }\n\n      // Fetch full data from OPDB\n      const opdbClient = new OPDBClient(env.OPDB_API_KEY, env.OPDB_API_URL);\n      const machineData = await opdbClient.getMachineById(input.opdbId);\n\n      if (!machineData) {\n        throw new Error(\"Game not found in OPDB\");\n      }\n\n      // Create global Model record with OPDB data\n      // OPDB games are shared across all organizations\n      return ctx.db.model.create({\n        data: {\n          name: machineData.name,\n          opdbId: input.opdbId,\n          manufacturer: machineData.manufacturer,\n          year: machineData.year,\n          opdbImgUrl: machineData.playfield_image,\n          machineType: machineData.type,\n        },\n      });\n    }),\n\n  // Sync existing titles with OPDB\n  syncWithOPDB: organizationManageProcedure.mutation(async ({ ctx }) => {\n    // Find all OPDB games that have game instances in this organization\n    const machinesInOrg = await ctx.db.machine.findMany({\n      where: {\n        organizationId: ctx.organization.id,\n      },\n      include: {\n        model: true,\n      },\n    });\n\n    const opdbGamesToSync = machinesInOrg\n      .map((gi) => gi.model)\n      .filter((gt) => gt.opdbId && !gt.opdbId.startsWith(\"custom-\"));\n\n    if (opdbGamesToSync.length === 0) {\n      return { synced: 0, message: \"No OPDB-linked games found to sync\" };\n    }\n\n    const opdbClient = new OPDBClient(env.OPDB_API_KEY, env.OPDB_API_URL);\n    let syncedCount = 0;\n\n    // Sync each title with OPDB data\n    for (const title of opdbGamesToSync) {\n      try {\n        if (!title.opdbId) continue; // Type guard\n\n        const machineData = await opdbClient.getMachineById(title.opdbId);\n\n        if (machineData) {\n          await ctx.db.model.update({\n            where: { id: title.id },\n            data: {\n              name: machineData.name,\n              manufacturer: machineData.manufacturer,\n              year: machineData.year,\n              opdbImgUrl: machineData.playfield_image,\n              machineType: machineData.type,\n            },\n          });\n          syncedCount++;\n        }\n      } catch (error) {\n        console.error(`Failed to sync game ${title.name}:`, error);\n      }\n    }\n\n    return {\n      synced: syncedCount,\n      total: opdbGamesToSync.length,\n      message: `Synced ${syncedCount} of ${opdbGamesToSync.length} games`,\n    };\n  }),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/model.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/notification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/organization.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 10,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 10,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "removeAsync",
            "fix": { "range": [223, 229], "text": "" },
            "desc": "Remove 'async'."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-deprecated",
        "severity": 2,
        "message": "`url` is deprecated. Use `z.url()` instead.",
        "line": 19,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "deprecatedWithReason",
        "endLine": 19,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from \"zod\";\n\nimport {\n  createTRPCRouter,\n  publicProcedure,\n  organizationManageProcedure,\n} from \"~/server/api/trpc\";\n\nexport const organizationRouter = createTRPCRouter({\n  getCurrent: publicProcedure.query(async ({ ctx }) => {\n    // Return the organization from context (resolved based on subdomain)\n    return ctx.organization;\n  }),\n\n  update: organizationManageProcedure\n    .input(\n      z.object({\n        name: z.string().min(1),\n        logoUrl: z.string().url().optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      const organization = await ctx.db.organization.update({\n        where: {\n          id: ctx.organization.id,\n        },\n        data: {\n          name: input.name,\n          logoUrl: input.logoUrl,\n        },\n      });\n      return organization;\n    }),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/pinballMap.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 13,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 13,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [424, 426], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 33,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 33,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [965, 967], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary optional chain on a non-nullish value.",
        "line": 67,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "neverOptionalChain",
        "endLine": 67,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestRemoveOptionalChain",
            "fix": { "range": [1964, 1966], "text": "." },
            "desc": "Remove unnecessary optional chain"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { TRPCError } from \"@trpc/server\";\nimport { z } from \"zod\";\n\nimport {\n  createTRPCRouter,\n  organizationManageProcedure,\n} from \"~/server/api/trpc\";\n\nexport const pinballMapRouter = createTRPCRouter({\n  // Enable PinballMap integration for organization\n  enableIntegration: organizationManageProcedure.mutation(async ({ ctx }) => {\n    const service = ctx.services.createPinballMapService();\n    if (!ctx.organization?.id) {\n      throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Organization not found\",\n      });\n    }\n    await service.enableIntegration(ctx.organization.id);\n    return { success: true };\n  }),\n\n  // Configure location for sync\n  configureLocation: organizationManageProcedure\n    .input(\n      z.object({\n        locationId: z.string(),\n        pinballMapId: z.number(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      const service = ctx.services.createPinballMapService();\n      if (!ctx.organization?.id) {\n        throw new TRPCError({\n          code: \"NOT_FOUND\",\n          message: \"Organization not found\",\n        });\n      }\n      await service.configureLocationSync(\n        input.locationId,\n        input.pinballMapId,\n        ctx.organization.id,\n      );\n      return { success: true };\n    }),\n\n  // Sync a specific location\n  syncLocation: organizationManageProcedure\n    .input(z.object({ locationId: z.string() }))\n    .mutation(async ({ ctx, input }) => {\n      const service = ctx.services.createPinballMapService();\n      const result = await service.syncLocation(input.locationId);\n\n      if (!result.success) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: result.error ?? \"Sync failed\",\n        });\n      }\n\n      return result;\n    }),\n\n  // Get sync status for organization\n  getSyncStatus: organizationManageProcedure.query(async ({ ctx }) => {\n    const service = ctx.services.createPinballMapService();\n    if (!ctx.organization?.id) {\n      throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Organization not found\",\n      });\n    }\n    return service.getOrganizationSyncStatus(ctx.organization.id);\n  }),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/qrCode.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/routers/user.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 46,
        "column": 69,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 46,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "removeAsync",
            "fix": { "range": [1115, 1121], "text": "" },
            "desc": "Remove 'async'."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 197,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "neverNullish",
        "endLine": 197,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from \"zod\";\n\nimport { imageStorage } from \"~/lib/image-storage/local-storage\";\nimport { getDefaultAvatarUrl } from \"~/lib/utils/image-processing\";\nimport {\n  createTRPCRouter,\n  protectedProcedure,\n  organizationProcedure,\n} from \"~/server/api/trpc\";\n\nexport const userRouter = createTRPCRouter({\n  // Get current user's profile\n  getProfile: protectedProcedure.query(async ({ ctx }) => {\n    const user = await ctx.db.user.findUnique({\n      where: { id: ctx.session.user.id },\n      include: {\n        ownedMachines: {\n          include: {\n            model: true,\n            location: true,\n          },\n        },\n        memberships: {\n          include: {\n            organization: true,\n          },\n        },\n        _count: {\n          select: {\n            issuesCreated: true,\n            comments: true,\n            ownedMachines: true,\n          },\n        },\n      },\n    });\n\n    if (!user) {\n      throw new Error(\"User not found\");\n    }\n\n    return user;\n  }),\n\n  // Get current user's membership info in the current organization\n  getCurrentMembership: organizationProcedure.query(async ({ ctx }) => {\n    return {\n      userId: ctx.membership.userId,\n      role: ctx.membership.role.name,\n      organizationId: ctx.membership.organizationId,\n      permissions: ctx.userPermissions,\n    };\n  }),\n\n  // Update user profile\n  updateProfile: protectedProcedure\n    .input(\n      z.object({\n        name: z.string().min(1).max(100).optional(),\n        bio: z.string().max(500).optional(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      const updatedUser = await ctx.db.user.update({\n        where: { id: ctx.session.user.id },\n        data: {\n          ...(input.name !== undefined && { name: input.name }),\n          ...(input.bio !== undefined && { bio: input.bio }),\n        },\n      });\n\n      return updatedUser;\n    }),\n\n  // Upload profile picture\n  uploadProfilePicture: protectedProcedure\n    .input(\n      z.object({\n        imageData: z.string(), // Base64 encoded image data\n        filename: z.string(),\n      }),\n    )\n    .mutation(async ({ ctx, input }) => {\n      try {\n        // Convert base64 to File object\n        const response = await fetch(input.imageData);\n        const blob = await response.blob();\n        const file = new File([blob], input.filename, { type: blob.type });\n\n        // Upload image\n        const imagePath = await imageStorage.uploadImage(\n          file,\n          `user-${ctx.session.user.id}`,\n        );\n\n        // Delete old profile picture if it exists\n        const currentUser = await ctx.db.user.findUnique({\n          where: { id: ctx.session.user.id },\n          select: { profilePicture: true },\n        });\n\n        if (\n          currentUser?.profilePicture &&\n          !currentUser.profilePicture.includes(\"default-avatar\")\n        ) {\n          try {\n            await imageStorage.deleteImage(currentUser.profilePicture);\n          } catch (error) {\n            // Ignore deletion errors for old files\n            console.warn(\"Failed to delete old profile picture:\", error);\n          }\n        }\n\n        // Update user's profile picture\n        const updatedUser = await ctx.db.user.update({\n          where: { id: ctx.session.user.id },\n          data: { profilePicture: imagePath },\n        });\n\n        return { success: true, profilePicture: updatedUser.profilePicture };\n      } catch (error) {\n        console.error(\"Profile picture upload error:\", error);\n        throw new Error(\"Failed to upload profile picture\");\n      }\n    }),\n\n  // Get user by ID (public info only - within organization context)\n  getUser: organizationProcedure\n    .input(z.object({ userId: z.string() }))\n    .query(async ({ ctx, input }) => {\n      // Verify user is a member of the current organization\n      const membership = await ctx.db.membership.findUnique({\n        where: {\n          userId_organizationId: {\n            userId: input.userId,\n            organizationId: ctx.membership.organizationId,\n          },\n        },\n        include: {\n          user: {\n            select: {\n              id: true,\n              name: true,\n              bio: true,\n              profilePicture: true,\n              createdAt: true,\n              _count: {\n                select: {\n                  ownedMachines: true,\n                  issuesCreated: true,\n                  comments: true,\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (!membership) {\n        throw new Error(\"User not found in this organization\");\n      }\n\n      return membership.user;\n    }),\n\n  // Get all users in the current organization\n  getAllInOrganization: organizationProcedure.query(async ({ ctx }) => {\n    const memberships = await ctx.db.membership.findMany({\n      where: { organizationId: ctx.membership.organizationId },\n      include: {\n        role: true,\n        user: {\n          select: {\n            id: true,\n            name: true,\n            bio: true,\n            profilePicture: true,\n            createdAt: true,\n            _count: {\n              select: {\n                ownedMachines: true,\n                issuesCreated: true,\n                comments: true,\n              },\n            },\n          },\n        },\n      },\n      orderBy: {\n        user: {\n          name: \"asc\",\n        },\n      },\n    });\n\n    return memberships.map((m) => ({\n      ...(m.user ?? {}),\n      role: m.role.name,\n    }));\n  }),\n\n  // Assign default avatar to user (used during account creation)\n  assignDefaultAvatar: protectedProcedure.mutation(async ({ ctx }) => {\n    const user = await ctx.db.user.findUnique({\n      where: { id: ctx.session.user.id },\n      select: { profilePicture: true },\n    });\n\n    // Only assign if user doesn't already have a profile picture\n    if (!user?.profilePicture) {\n      const defaultAvatarUrl = getDefaultAvatarUrl();\n\n      await ctx.db.user.update({\n        where: { id: ctx.session.user.id },\n        data: { profilePicture: defaultAvatarUrl },\n      });\n\n      return { profilePicture: defaultAvatarUrl };\n    }\n\n    return { profilePicture: user.profilePicture };\n  }),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/trpc.base.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary conditional, value is always falsy.",
        "line": 210,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "alwaysFalsy",
        "endLine": 210,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Base tRPC procedures and middleware\n *\n * This file contains the fundamental building blocks for tRPC procedures\n * that are used across the application. It's separated to avoid circular\n * dependencies between trpc.ts and trpc.permission.ts.\n */\n\nimport { initTRPC, TRPCError } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nimport type { Session } from \"next-auth\";\nimport type { ExtendedPrismaClient } from \"~/server/db\";\n\nimport { env } from \"~/env\";\nimport { auth } from \"~/server/auth\";\nimport { getGlobalDatabaseProvider } from \"~/server/db/provider\";\nimport { ServiceFactory } from \"~/server/services/factory\";\n\n/**\n * Base context interface for tRPC\n */\ninterface CreateTRPCContextOptions {\n  headers: Headers;\n}\n\n/**\n * Organization type for context\n */\ninterface Organization {\n  id: string;\n  subdomain: string;\n  name: string;\n  // Add other fields as needed\n}\n\n/**\n * Permission type for context\n */\ninterface Permission {\n  id: string;\n  name: string;\n}\n\n/**\n * Role type for context\n */\ninterface Role {\n  id: string;\n  name: string;\n  permissions: Permission[];\n}\n\n/**\n * Membership type for context\n */\ninterface Membership {\n  id: string;\n  organizationId: string;\n  userId: string;\n  role: Role;\n}\n\n/**\n * tRPC context type that includes all available properties\n */\nexport interface TRPCContext {\n  db: ExtendedPrismaClient;\n  session: Session | null;\n  organization: Organization;\n  services: ServiceFactory;\n  headers: Headers;\n}\n\n/**\n * Enhanced context for protected procedures with authenticated user\n */\nexport interface ProtectedTRPCContext extends TRPCContext {\n  session: Session & {\n    user: NonNullable<Session[\"user\"]>;\n  };\n}\n\n/**\n * Enhanced context for organization procedures with membership info\n */\nexport interface OrganizationTRPCContext extends ProtectedTRPCContext {\n  membership: Membership;\n  userPermissions: string[];\n}\n\n/**\n * Context creation for tRPC\n */\nexport const createTRPCContext = async (\n  opts: CreateTRPCContextOptions,\n): Promise<TRPCContext> => {\n  const dbProvider = getGlobalDatabaseProvider();\n\n  const db = dbProvider.getClient();\n  const services = new ServiceFactory(db);\n  const session = await auth();\n\n  let organization: Organization | null = null;\n\n  // If user is authenticated and has organization context, use that\n  if (session?.user.organizationId) {\n    const org = await db.organization.findUnique({\n      where: { id: session.user.organizationId },\n    });\n    if (org) {\n      organization = org as Organization;\n    }\n  }\n\n  // Extract subdomain from headers (set by middleware)\n  const subdomain =\n    opts.headers.get(\"x-subdomain\") ?? env.DEFAULT_ORG_SUBDOMAIN;\n\n  // Fallback to organization based on subdomain\n  if (!organization) {\n    const org = await db.organization.findUnique({\n      where: { subdomain },\n    });\n    if (org) {\n      organization = org as Organization;\n    }\n  }\n\n  if (!organization) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: `Organization with subdomain \"${subdomain}\" not found.`,\n    });\n  }\n\n  return {\n    db,\n    session,\n    organization,\n    services,\n    headers: opts.headers,\n  };\n};\n\n/**\n * tRPC initialization\n */\nconst t = initTRPC.context<TRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError: error.cause instanceof ZodError ? error.cause.issues : null,\n      },\n    };\n  },\n});\n\nexport const createCallerFactory = t.createCallerFactory;\nexport const createTRPCRouter = t.router;\n\n/**\n * Timing middleware\n */\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\n  const start = Date.now();\n\n  if (t._config.isDev) {\n    // artificial delay in dev\n    const waitMs = Math.floor(Math.random() * 400) + 100;\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  const result = await next();\n\n  const end = Date.now();\n  if (env.NODE_ENV !== \"test\") {\n    console.log(`[TRPC] ${path} took ${String(end - start)}ms to execute`);\n  }\n\n  return result;\n});\n\n/**\n * Base procedures\n */\nexport const publicProcedure = t.procedure.use(timingMiddleware);\n\nexport const protectedProcedure = t.procedure\n  .use(timingMiddleware)\n  .use(({ ctx, next }) => {\n    if (!ctx.session?.user) {\n      throw new TRPCError({ code: \"UNAUTHORIZED\" });\n    }\n    return next({\n      ctx: {\n        ...ctx,\n        // infers the `session` as non-nullable\n        session: { ...ctx.session, user: ctx.session.user },\n      } satisfies ProtectedTRPCContext,\n    });\n  });\n\nexport const organizationProcedure = protectedProcedure.use(\n  async ({ ctx, next }) => {\n    if (!ctx.organization) {\n      throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: \"Organization not found\",\n      });\n    }\n\n    const membership = await ctx.db.membership.findFirst({\n      where: {\n        organizationId: ctx.organization.id,\n        userId: ctx.session.user.id,\n      },\n      include: {\n        role: {\n          include: {\n            permissions: true,\n          },\n        },\n      },\n    });\n\n    if (!membership) {\n      throw new TRPCError({\n        code: \"FORBIDDEN\",\n        message: \"You don't have permission to access this organization\",\n      });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        membership: membership as Membership,\n\n        userPermissions: membership.role.permissions.map(\n          (p: { name: string }) => p.name,\n        ),\n      } satisfies OrganizationTRPCContext,\n    });\n  },\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/trpc.permission.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/api/trpc.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/auth/config.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/dot-notation",
        "severity": 2,
        "message": "[\"id\"] is better written in dot notation.",
        "line": 102,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 102,
        "endColumn": 51,
        "fix": { "range": [3014, 3020], "text": ".id" }
      },
      {
        "ruleId": "@typescript-eslint/dot-notation",
        "severity": 2,
        "message": "[\"id\"] is better written in dot notation.",
        "line": 103,
        "column": 29,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 103,
        "endColumn": 33,
        "fix": { "range": [3064, 3070], "text": ".id" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 2,
    "fixableWarningCount": 0,
    "source": "import { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { type DefaultSession, type NextAuthConfig } from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport Google from \"next-auth/providers/google\";\n\nimport { isValidUser, isValidOrganization, isValidMembership } from \"./types\";\n\nimport type { Session } from \"next-auth\";\nimport type { User } from \"next-auth\";\nimport type { JWT } from \"next-auth/jwt\";\nimport type { ExtendedPrismaClient } from \"~/server/db\";\n\nimport { env } from \"~/env.js\";\n\n/**\n * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`\n * object and keep type safety.\n *\n * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n */\ndeclare module \"next-auth\" {\n  interface Session extends DefaultSession {\n    user: {\n      id: string;\n      role?: string;\n      organizationId?: string;\n    } & DefaultSession[\"user\"];\n  }\n\n  interface JWT {\n    id: string;\n    role?: string;\n    organizationId?: string;\n  }\n}\n\n/**\n * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n *\n * @see https://next-auth.js.org/configuration/options\n */\nexport const createAuthConfig = (db: ExtendedPrismaClient): NextAuthConfig => ({\n  adapter: PrismaAdapter(db),\n  providers: [\n    Google({\n      clientId: env.GOOGLE_CLIENT_ID ?? \"\",\n      clientSecret: env.GOOGLE_CLIENT_SECRET ?? \"\",\n    }),\n    // Development-only Credentials provider for test accounts\n    ...(env.NODE_ENV === \"development\" || env.NODE_ENV === \"test\"\n      ? [\n          Credentials({\n            name: \"Development Test Users\",\n            credentials: {\n              email: { label: \"Email\", type: \"email\" },\n            },\n            async authorize(\n              credentials: Record<string, unknown> | undefined,\n            ): Promise<User | null> {\n              if (env.NODE_ENV !== \"development\" && env.NODE_ENV !== \"test\") {\n                return null;\n              }\n\n              if (\n                !credentials ||\n                !(\"email\" in credentials) ||\n                typeof credentials[\"email\"] !== \"string\"\n              ) {\n                return null;\n              }\n\n              const email = credentials[\"email\"];\n\n              // Find user in database by email\n              const userResult = await db.user.findUnique({\n                where: { email },\n              });\n\n              if (isValidUser(userResult)) {\n                return {\n                  id: userResult.id,\n                  name: userResult.name ?? \"\",\n                  email: userResult.email ?? \"\",\n                  image: userResult.profilePicture ?? null,\n                };\n              }\n\n              return null;\n            },\n          }),\n        ]\n      : []),\n  ],\n  pages: {\n    signIn: \"/sign-in\",\n  },\n  session: {\n    strategy: \"jwt\",\n  },\n  callbacks: {\n    jwt: async ({ token, user }: { token: JWT; user?: User }): Promise<JWT> => {\n      if (user && \"id\" in user && typeof user[\"id\"] === \"string\") {\n        const userId = user[\"id\"];\n        token[\"id\"] = userId;\n\n        // Get the user's membership in the current organization\n        // Note: In JWT callback, we don't have access to request headers/subdomain,\n        // so we default to APC. The organization context will be properly resolved\n        // in tRPC context based on subdomain.\n        const organizationResult = await db.organization.findUnique({\n          where: { subdomain: \"apc\" },\n        });\n\n        if (isValidOrganization(organizationResult)) {\n          const membershipResult = await db.membership.findUnique({\n            where: {\n              userId_organizationId: {\n                userId,\n                organizationId: organizationResult.id,\n              },\n            },\n            include: {\n              role: true,\n            },\n          });\n\n          if (isValidMembership(membershipResult)) {\n            token[\"role\"] = membershipResult.role.name;\n            token[\"organizationId\"] = organizationResult.id;\n          }\n        }\n      }\n      return token;\n    },\n    session: ({\n      session,\n      token,\n    }: {\n      session: Session;\n      token: JWT;\n    }): Session => {\n      // For JWT sessions, get data from token\n      const userUpdate: {\n        id: string;\n        role?: string;\n        organizationId?: string;\n      } = {\n        id: typeof token[\"id\"] === \"string\" ? token[\"id\"] : \"\",\n      };\n\n      if (typeof token[\"role\"] === \"string\") {\n        userUpdate.role = token[\"role\"];\n      }\n\n      if (typeof token[\"organizationId\"] === \"string\") {\n        userUpdate.organizationId = token[\"organizationId\"];\n      }\n\n      return {\n        ...session,\n        user: {\n          ...session.user,\n          ...userUpdate,\n        },\n      };\n    },\n  },\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/auth/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/auth/permissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/auth/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/auth/uploadAuth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/constants/cleanup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/db.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 6,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 6,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { PrismaClient } from \"@prisma/client\";\nimport { withAccelerate } from \"@prisma/extension-accelerate\";\n\nimport { env } from \"~/env\";\n\nfunction createPrismaClientInternal() {\n  const baseClient = new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\n  // Always extend with Accelerate for consistent typing\n  // In development, Accelerate operations will fall back to regular Prisma\n  return baseClient.$extends(withAccelerate());\n}\n\n// Type alias for the extended Prisma client used throughout the application\nexport type ExtendedPrismaClient = ReturnType<\n  typeof createPrismaClientInternal\n>;\n\nexport const createPrismaClient = (): ExtendedPrismaClient => {\n  return createPrismaClientInternal();\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/db/provider.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 2,
        "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
        "line": 7,
        "column": 5,
        "nodeType": "IfStatement",
        "messageId": "preferNullishOverAssignment",
        "endLine": 9,
        "endColumn": 6,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "=" },
            "fix": {
              "range": [196, 267],
              "text": "this.instance ??= createPrismaClient();"
            },
            "desc": "Fix to nullish coalescing operator (`??=`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 2,
        "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
        "line": 30,
        "column": 3,
        "nodeType": "IfStatement",
        "messageId": "preferNullishOverAssignment",
        "endLine": 32,
        "endColumn": 4,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "data": { "equals": "=" },
            "fix": {
              "range": [677, 748],
              "text": "globalProvider ??= new DatabaseProvider();"
            },
            "desc": "Fix to nullish coalescing operator (`??=`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { createPrismaClient, type ExtendedPrismaClient } from \"~/server/db\";\n\nexport class DatabaseProvider {\n  private instance?: ExtendedPrismaClient;\n\n  getClient(): ExtendedPrismaClient {\n    if (!this.instance) {\n      this.instance = createPrismaClient();\n    }\n    return this.instance;\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.instance) {\n      await this.instance.$disconnect();\n      delete this.instance;\n    }\n  }\n\n  // For testing purposes\n  reset(): void {\n    delete this.instance;\n  }\n}\n\n// Singleton provider for production use\nlet globalProvider: DatabaseProvider | undefined;\n\nexport function getGlobalDatabaseProvider(): DatabaseProvider {\n  if (!globalProvider) {\n    globalProvider = new DatabaseProvider();\n  }\n  return globalProvider;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/collectionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/commentCleanupService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/factory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/issueActivityService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/notificationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/pinballmapService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"string | null | undefined\" of template literal expression.",
        "line": 218,
        "column": 51,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 218,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 288,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "neverNullish",
        "endLine": 288,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"number\" of template literal expression.",
        "line": 334,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 334,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"number\" of template literal expression.",
        "line": 338,
        "column": 50,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 338,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * PinballMap synchronization service for V1.0 schema\n * Handles syncing machine data between PinballMap and PinPoint\n */\n\nimport type { ExtendedPrismaClient } from \"./types\";\nimport type {\n  PinballMapMachine,\n  PinballMapMachineDetailsResponse,\n} from \"../../lib/pinballmap/types\";\n\nexport interface SyncResult {\n  success: boolean;\n  added: number;\n  updated: number;\n  removed: number;\n  error?: string;\n}\n\nexport class PinballMapService {\n  constructor(private prisma: ExtendedPrismaClient) {}\n\n  /**\n   * Enable PinballMap integration for an organization\n   */\n  async enableIntegration(organizationId: string): Promise<void> {\n    await this.prisma.pinballMapConfig.upsert({\n      where: { organizationId },\n      create: {\n        organizationId,\n        apiEnabled: true,\n        autoSyncEnabled: false, // Start with manual sync\n      },\n      update: {\n        apiEnabled: true,\n      },\n    });\n  }\n\n  /**\n   * Configure a location for PinballMap sync\n   */\n  async configureLocationSync(\n    locationId: string,\n    pinballMapId: number,\n    organizationId: string,\n  ): Promise<void> {\n    // Verify organization has PinballMap enabled\n    const config = await this.prisma.pinballMapConfig.findUnique({\n      where: { organizationId },\n    });\n\n    if (!config?.apiEnabled) {\n      throw new Error(\"PinballMap integration not enabled for organization\");\n    }\n\n    // Update location with PinballMap configuration\n    await this.prisma.location.update({\n      where: { id: locationId },\n      data: {\n        pinballMapId,\n        syncEnabled: true,\n      },\n    });\n  }\n\n  /**\n   * Sync a specific location with PinballMap\n   */\n  async syncLocation(locationId: string): Promise<SyncResult> {\n    const location = await this.prisma.location.findUnique({\n      where: { id: locationId },\n      include: {\n        organization: {\n          include: {\n            pinballMapConfig: true,\n          },\n        },\n      },\n    });\n\n    if (!location) {\n      return {\n        success: false,\n        added: 0,\n        updated: 0,\n        removed: 0,\n        error: \"Location not found\",\n      };\n    }\n\n    if (!location.pinballMapId) {\n      return {\n        success: false,\n        added: 0,\n        updated: 0,\n        removed: 0,\n        error: \"Location not configured for PinballMap sync\",\n      };\n    }\n\n    if (!location.organization.pinballMapConfig?.apiEnabled) {\n      return {\n        success: false,\n        added: 0,\n        updated: 0,\n        removed: 0,\n        error: \"PinballMap integration not enabled\",\n      };\n    }\n\n    try {\n      // Fetch machine data from PinballMap\n      const machineData = await this.fetchLocationMachines(\n        location.pinballMapId,\n      );\n\n      if (!machineData?.machines) {\n        return {\n          success: false,\n          added: 0,\n          updated: 0,\n          removed: 0,\n          error: \"No machine data returned from PinballMap\",\n        };\n      }\n\n      // Process the machines\n      const result = await this.reconcileMachines(\n        location.id,\n        location.organizationId,\n        machineData.machines,\n        location.organization.pinballMapConfig,\n      );\n\n      // Update last sync time\n      await this.prisma.location.update({\n        where: { id: locationId },\n        data: { lastSyncAt: new Date() },\n      });\n\n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        added: 0,\n        updated: 0,\n        removed: 0,\n        error: error instanceof Error ? error.message : \"Unknown sync error\",\n      };\n    }\n  }\n\n  /**\n   * Reconcile PinballMap machines with local database\n   */\n  private async reconcileMachines(\n    locationId: string,\n    organizationId: string,\n    pinballMapMachines: PinballMapMachine[],\n    config: { createMissingModels: boolean; updateExistingData: boolean },\n  ): Promise<SyncResult> {\n    let added = 0;\n    let updated = 0;\n    let removed = 0;\n\n    // Get current machines at this location\n    const currentMachines = await this.prisma.machine.findMany({\n      where: { locationId },\n      include: {\n        model: true,\n      },\n    });\n\n    // Track which machines we found on PinballMap\n    const foundMachineIds = new Set<string>();\n\n    for (const pmMachine of pinballMapMachines) {\n      try {\n        // Find or create the Model record\n        const model = await this.findOrCreateModel(\n          pmMachine,\n          config.createMissingModels,\n        );\n\n        if (!model) {\n          continue; // Skip if model creation is disabled and model doesn't exist\n        }\n\n        // Find existing machine by model and location\n        const existingMachine = currentMachines.find(\n          (m) => m.modelId === model.id,\n        );\n\n        if (existingMachine) {\n          foundMachineIds.add(existingMachine.id);\n\n          if (config.updateExistingData) {\n            // Update existing machine if needed\n            // For now, machines don't have updatable fields from PinballMap\n            // This could be expanded for condition, notes, etc.\n            updated++;\n          }\n        } else {\n          // Create new machine\n          await this.prisma.machine.create({\n            data: {\n              name: model.name, // Use model name as default instance name\n              organizationId,\n              locationId,\n              modelId: model.id,\n              // ownerId will be null initially\n            },\n          });\n          added++;\n        }\n      } catch (error) {\n        console.error(`Error processing machine ${pmMachine.opdb_id}:`, error);\n        // Continue processing other machines\n      }\n    }\n\n    // Remove machines that are no longer on PinballMap\n    const machinesToRemove = currentMachines.filter(\n      (m) => !foundMachineIds.has(m.id),\n    );\n\n    for (const machine of machinesToRemove) {\n      // Check if machine has issues before removing\n      const issueCount = await this.prisma.issue.count({\n        where: { machineId: machine.id },\n      });\n\n      if (issueCount === 0) {\n        // Only remove machines with no issues\n        await this.prisma.machine.delete({\n          where: { id: machine.id },\n        });\n        removed++;\n      }\n    }\n\n    return {\n      success: true,\n      added,\n      updated,\n      removed,\n    };\n  }\n\n  /**\n   * Find existing Model or create new one from PinballMap data\n   */\n  private async findOrCreateModel(\n    pmMachine: PinballMapMachine,\n    createMissingModels: boolean,\n  ): Promise<{ id: string; name: string } | null> {\n    // Look for existing model by OPDB ID\n    let model = pmMachine.opdb_id\n      ? await this.prisma.model.findUnique({\n          where: { opdbId: pmMachine.opdb_id },\n        })\n      : null;\n\n    if (model) {\n      return model;\n    }\n\n    // Look for existing model by IPDB ID if available\n    if (pmMachine.ipdb_id) {\n      model = await this.prisma.model.findUnique({\n        where: { ipdbId: pmMachine.ipdb_id },\n      });\n\n      if (model) {\n        return model;\n      }\n    }\n\n    if (!createMissingModels) {\n      return null;\n    }\n\n    // Create new global model from PinballMap data\n    try {\n      model = await this.prisma.model.create({\n        data: {\n          name: pmMachine.machine_name ?? pmMachine.name,\n          manufacturer: pmMachine.manufacturer ?? null,\n          year: pmMachine.year ?? null,\n\n          // Cross-database references\n          opdbId: pmMachine.opdb_id,\n          ipdbId: pmMachine.ipdb_id ?? null,\n\n          // Technical details\n          machineType: pmMachine.machine_type ?? null,\n          machineDisplay: pmMachine.machine_display ?? null,\n          isActive: pmMachine.is_active ?? true,\n\n          // Metadata and links\n          ipdbLink: pmMachine.ipdb_link ?? null,\n          opdbImgUrl: pmMachine.opdb_img ?? null,\n          kineticistUrl: pmMachine.kineticist_url ?? null,\n\n          // PinPoint-specific\n          isCustom: false, // OPDB games are not custom\n        },\n      });\n\n      return model;\n    } catch (error) {\n      // Handle duplicate key errors gracefully\n      if (error instanceof Error && error.message.includes(\"unique\")) {\n        // Another sync might have created this model\n        return pmMachine.opdb_id\n          ? this.prisma.model.findUnique({\n              where: { opdbId: pmMachine.opdb_id },\n            })\n          : null;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch machine data from PinballMap API\n   */\n  private async fetchLocationMachines(\n    pinballMapId: number,\n  ): Promise<PinballMapMachineDetailsResponse | null> {\n    try {\n      const response = await fetch(\n        `https://pinballmap.com/api/v1/locations/${pinballMapId}/machine_details.json`,\n      );\n\n      if (!response.ok) {\n        throw new Error(`PinballMap API error: ${response.status}`);\n      }\n\n      const result: unknown = await response.json();\n      return result as PinballMapMachineDetailsResponse;\n    } catch (error) {\n      console.error(\"Failed to fetch PinballMap data:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Get sync status for all locations in an organization\n   */\n  async getOrganizationSyncStatus(organizationId: string): Promise<{\n    configEnabled: boolean;\n    locations: {\n      id: string;\n      name: string;\n      pinballMapId: number | null;\n      syncEnabled: boolean;\n      lastSyncAt: Date | null;\n      machineCount: number;\n    }[];\n  }> {\n    const config = await this.prisma.pinballMapConfig.findUnique({\n      where: { organizationId },\n    });\n\n    const locations = await this.prisma.location.findMany({\n      where: { organizationId },\n      include: {\n        _count: {\n          select: {\n            machines: true,\n          },\n        },\n      },\n    });\n\n    return {\n      configEnabled: config?.apiEnabled ?? false,\n      locations: locations.map((location) => ({\n        id: location.id,\n        name: location.name,\n        pinballMapId: location.pinballMapId,\n        syncEnabled: location.syncEnabled,\n        lastSyncAt: location.lastSyncAt,\n        machineCount: location._count.machines,\n      })),\n    };\n  }\n}\n\n// Export legacy functions for backward compatibility during transition\nexport async function syncLocationGames(\n  prisma: ExtendedPrismaClient,\n  locationId: string,\n): Promise<SyncResult> {\n  const service = new PinballMapService(prisma);\n  return service.syncLocation(locationId);\n}\n\nexport async function processFixtureData(\n  prisma: ExtendedPrismaClient,\n  fixtureData: PinballMapMachineDetailsResponse,\n  locationId: string,\n  organizationId: string,\n): Promise<{ created: number; error?: string }> {\n  try {\n    let created = 0;\n    const service = new PinballMapService(prisma);\n\n    for (const machine of fixtureData.machines) {\n      // Create or update model\n      const model = await service.findOrCreateModel(machine, true);\n\n      if (model) {\n        // Create machine instance\n        await prisma.machine.create({\n          data: {\n            name: model.name, // Use model name as default instance name\n            organizationId: organizationId,\n            modelId: model.id,\n            locationId: locationId,\n          },\n        });\n        created++;\n      }\n    }\n\n    return { created };\n  } catch (error) {\n    return {\n      created: 0,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/qrCodeService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unnecessary-condition",
        "severity": 2,
        "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
        "line": 94,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "neverNullish",
        "endLine": 94,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as QRCode from \"qrcode\";\n\nimport { type Machine, type ExtendedPrismaClient } from \"./types\";\n\nimport { imageStorage } from \"~/lib/image-storage/local-storage\";\nimport { constructReportUrl } from \"~/server/utils/qrCodeUtils\";\n\nexport interface QRCodeInfo {\n  id: string;\n  url: string | null;\n  generatedAt: Date | null;\n}\n\nexport interface MachineFromQRCode {\n  id: string;\n  name: string;\n  organizationId: string;\n  locationId: string;\n  model: {\n    name: string;\n    manufacturer: string | null;\n  };\n  location: {\n    name: string;\n  };\n  organization: {\n    name: string;\n    subdomain: string | null;\n  };\n}\n\nexport interface BulkGenerationResult {\n  generated: number;\n  failed: number;\n  total: number;\n}\n\nexport class QRCodeService {\n  constructor(private prisma: ExtendedPrismaClient) {}\n\n  /**\n   * Generate QR code for a machine\n   */\n  async generateQRCode(machineId: string): Promise<QRCodeInfo> {\n    // Get machine details for QR code content\n    const machine = await this.prisma.machine.findUnique({\n      where: { id: machineId },\n      include: {\n        organization: {\n          select: { subdomain: true },\n        },\n      },\n    });\n\n    if (!machine) {\n      throw new Error(\"Machine not found\");\n    }\n\n    // Generate QR code content URL\n    const qrContent = this.generateQRCodeContent(machine);\n\n    // Generate QR code as buffer\n    const qrCodeBuffer = await QRCode.toBuffer(qrContent, {\n      type: \"png\",\n      width: 400,\n      margin: 2,\n      color: {\n        dark: \"#000000\",\n        light: \"#FFFFFF\",\n      },\n    });\n\n    // Upload QR code image directly from buffer\n    const qrCodeUrl = await imageStorage.uploadQRCode(\n      qrCodeBuffer,\n      `qr-codes/machine-${String(machine.id)}/qr-code-${String(machine.id)}`,\n    );\n\n    // Update machine with QR code information\n    const updatedMachine = await this.prisma.machine.update({\n      where: { id: machineId },\n      data: {\n        qrCodeUrl,\n        qrCodeGeneratedAt: new Date(),\n      },\n      select: {\n        qrCodeId: true,\n        qrCodeUrl: true,\n        qrCodeGeneratedAt: true,\n      },\n    });\n\n    return {\n      id: updatedMachine.qrCodeId ?? \"\",\n      url: updatedMachine.qrCodeUrl,\n      generatedAt: updatedMachine.qrCodeGeneratedAt,\n    };\n  }\n\n  /**\n   * Get QR code information for a machine\n   */\n  async getQRCodeInfo(machineId: string): Promise<QRCodeInfo | null> {\n    const machine = await this.prisma.machine.findUnique({\n      where: { id: machineId },\n      select: {\n        qrCodeId: true,\n        qrCodeUrl: true,\n        qrCodeGeneratedAt: true,\n      },\n    });\n\n    if (!machine) {\n      throw new Error(\"Machine not found\");\n    }\n\n    if (!machine.qrCodeUrl || !machine.qrCodeGeneratedAt || !machine.qrCodeId) {\n      return null;\n    }\n\n    return {\n      id: machine.qrCodeId,\n      url: machine.qrCodeUrl,\n      generatedAt: machine.qrCodeGeneratedAt,\n    };\n  }\n\n  /**\n   * Regenerate QR code for a machine (delete old and create new)\n   */\n  async regenerateQRCode(machineId: string): Promise<QRCodeInfo> {\n    const machine = await this.prisma.machine.findUnique({\n      where: { id: machineId },\n      select: { qrCodeUrl: true },\n    });\n\n    if (!machine) {\n      throw new Error(\"Machine not found\");\n    }\n\n    // Delete old QR code image if it exists\n    if (machine.qrCodeUrl) {\n      try {\n        await imageStorage.deleteImage(machine.qrCodeUrl);\n      } catch (error) {\n        // Log error but don't fail regeneration\n        console.warn(`Failed to delete old QR code image: ${String(error)}`);\n      }\n    }\n\n    // Generate new QR code\n    return this.generateQRCode(machineId);\n  }\n\n  /**\n   * Resolve machine information from QR code ID\n   */\n  async resolveMachineFromQR(\n    qrCodeId: string,\n  ): Promise<MachineFromQRCode | null> {\n    const machine = await this.prisma.machine.findUnique({\n      where: { qrCodeId },\n      include: {\n        model: {\n          select: {\n            name: true,\n            manufacturer: true,\n          },\n        },\n        location: {\n          select: {\n            name: true,\n          },\n        },\n        organization: {\n          select: {\n            name: true,\n            subdomain: true,\n          },\n        },\n      },\n    });\n\n    if (!machine) {\n      return null;\n    }\n\n    return {\n      id: machine.id,\n      name: machine.name,\n      organizationId: machine.organizationId,\n      locationId: machine.locationId,\n      model: machine.model,\n      location: machine.location,\n      organization: machine.organization,\n    };\n  }\n\n  /**\n   * Generate QR codes for all machines in an organization\n   */\n  async generateQRCodesForOrganization(\n    organizationId: string,\n  ): Promise<BulkGenerationResult> {\n    const machines = await this.prisma.machine.findMany({\n      where: {\n        organizationId,\n        qrCodeUrl: null, // Only generate for machines without QR codes\n      },\n      select: { id: true },\n    });\n\n    let generated = 0;\n    let failed = 0;\n    const total = machines.length;\n\n    for (const machine of machines) {\n      try {\n        await this.generateQRCode(machine.id);\n        generated++;\n      } catch (error) {\n        console.error(\n          `Failed to generate QR code for machine ${String(machine.id)}:`,\n          error,\n        );\n        failed++;\n      }\n    }\n\n    return { generated, failed, total };\n  }\n\n  /**\n   * Generate QR codes for all machines in an organization (including regeneration)\n   */\n  async regenerateQRCodesForOrganization(\n    organizationId: string,\n  ): Promise<BulkGenerationResult> {\n    const machines = await this.prisma.machine.findMany({\n      where: { organizationId },\n      select: { id: true },\n    });\n\n    let generated = 0;\n    let failed = 0;\n    const total = machines.length;\n\n    for (const machine of machines) {\n      try {\n        await this.regenerateQRCode(machine.id);\n        generated++;\n      } catch (error) {\n        console.error(\n          `Failed to regenerate QR code for machine ${String(machine.id)}:`,\n          error,\n        );\n        failed++;\n      }\n    }\n\n    return { generated, failed, total };\n  }\n\n  /**\n   * Generate the QR code content URL based on machine and organization\n   */\n  private generateQRCodeContent(\n    machine: Machine & { organization: { subdomain: string | null } },\n  ): string {\n    return constructReportUrl(machine);\n  }\n\n  /**\n   * Get QR code statistics for an organization\n   */\n  async getOrganizationQRCodeStats(organizationId: string): Promise<{\n    total: number;\n    withQRCodes: number;\n    withoutQRCodes: number;\n  }> {\n    const [total, withQRCodes] = await Promise.all([\n      this.prisma.machine.count({\n        where: { organizationId },\n      }),\n      this.prisma.machine.count({\n        where: {\n          organizationId,\n          qrCodeUrl: { not: null },\n        },\n      }),\n    ]);\n\n    return {\n      total,\n      withQRCodes,\n      withoutQRCodes: total - withQRCodes,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/services/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/server/utils/qrCodeUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/test/context.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 3,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 3,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { PrismaClient } from \"@prisma/client\";\n\nexport function createTestContext() {\n  const prisma = new PrismaClient();\n  // Optionally seed test org, etc. here\n  return {\n    prisma,\n    session: undefined,\n    organization: undefined,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/test/helpers/serviceHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/test/mockContext.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/test/setup.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 166,
        "column": 3,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 166,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 167,
        "column": 3,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 167,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .method on an `any` value.",
        "line": 167,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 167,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 1,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ArrayLike<unknown> | { [s: string]: unknown; }`.",
        "line": 168,
        "column": 35,
        "nodeType": "LogicalExpression",
        "messageId": "unsafeArgument",
        "endLine": 168,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .headers on an `any` value.",
        "line": 168,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 168,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 179,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 179,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 179,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 179,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 196,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 196,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 196,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 196,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import \"@testing-library/jest-dom\";\n\n// Mock environment variables for testing\nObject.defineProperty(process.env, \"NODE_ENV\", {\n  value: \"test\",\n  writable: true,\n  configurable: true,\n});\nprocess.env[\"AUTH_SECRET\"] = \"test-auth-secret\";\nprocess.env[\"NEXTAUTH_SECRET\"] = \"test-auth-secret\"; // Alternative name\nprocess.env[\"GOOGLE_CLIENT_ID\"] = \"test-google-client-id\";\nprocess.env[\"GOOGLE_CLIENT_SECRET\"] = \"test-google-client-secret\";\nprocess.env[\"DATABASE_URL\"] = \"postgresql://test:test@localhost:5432/test\";\nprocess.env[\"OPDB_API_URL\"] = \"https://opdb.org/api\";\nprocess.env[\"DEFAULT_ORG_SUBDOMAIN\"] = \"apc\";\nprocess.env[\"OPDB_API_KEY\"] = \"test-token\";\nprocess.env[\"IMAGE_STORAGE_PROVIDER\"] = \"local\";\nprocess.env[\"NEXTAUTH_URL\"] = \"http://localhost:3000\";\nprocess.env[\"VERCEL_URL\"] = \"\";\nprocess.env[\"PORT\"] = \"3000\";\n\n// Mock fetch globally for tests\nglobal.fetch = jest.fn();\n\n// Create a mock Prisma client\nconst mockPrismaClient = {\n  $disconnect: jest.fn().mockResolvedValue(undefined),\n  organization: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  user: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  membership: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  issue: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n    count: jest.fn(),\n  },\n  machine: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  location: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  attachment: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n    count: jest.fn(),\n  },\n  model: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  issueStatus: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  priority: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  issueHistory: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  notification: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  },\n  pinballMapConfig: {\n    findMany: jest.fn(),\n    findFirst: jest.fn(),\n    findUnique: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n    upsert: jest.fn(),\n  },\n};\n\n// Mock database module\njest.mock(\"~/server/db\", () => ({\n  createPrismaClient: jest.fn().mockReturnValue(mockPrismaClient),\n}));\n\n// Mock database provider\nconst mockDatabaseProvider = {\n  getClient: jest.fn().mockReturnValue(mockPrismaClient),\n  disconnect: jest.fn().mockResolvedValue(undefined),\n  reset: jest.fn(),\n};\n\njest.mock(\"~/server/db/provider\", () => ({\n  DatabaseProvider: jest.fn().mockImplementation(() => mockDatabaseProvider),\n  getGlobalDatabaseProvider: jest.fn().mockReturnValue(mockDatabaseProvider),\n}));\n\n// Mock NextAuth first to avoid import issues\njest.mock(\"next-auth\", () => {\n  return jest.fn().mockImplementation(() => ({\n    auth: jest.fn(),\n    handlers: { GET: jest.fn(), POST: jest.fn() },\n    signIn: jest.fn(),\n    signOut: jest.fn(),\n  }));\n});\n\n// Mock Next.js server APIs for tests\nglobal.Request = jest.fn().mockImplementation((input, init) => ({\n  url: input,\n  method: init?.method ?? \"GET\",\n  headers: new Map(Object.entries(init?.headers ?? {})),\n  json: jest.fn().mockResolvedValue({}),\n  text: jest.fn().mockResolvedValue(\"\"),\n}));\n\nglobal.Response = {\n  json: jest.fn().mockResolvedValue({}),\n  error: jest.fn(),\n  redirect: jest.fn(),\n  new: jest.fn().mockImplementation((body, init) => ({\n    ok: true,\n    status: init?.status ?? 200,\n    json: jest.fn().mockResolvedValue(body),\n    text: jest.fn().mockResolvedValue(String(body)),\n  })),\n} as unknown as {\n  new (body?: BodyInit | null, init?: ResponseInit): Response;\n  prototype: Response;\n  error(): Response;\n  json(data: unknown, init?: ResponseInit): Response;\n  redirect(url: string, status?: number): Response;\n};\n\n// Mock NextResponse\njest.mock(\"next/server\", () => ({\n  NextResponse: {\n    json: jest.fn().mockImplementation((data, init) => ({\n      json: jest.fn().mockResolvedValue(data),\n      status: init?.status ?? 200,\n    })),\n  },\n}));\n\n// Reset all mocks after each test\nafterEach(() => {\n  jest.clearAllMocks();\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/trpc/query-client.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 7,
        "column": 37,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 7,
        "endColumn": 39
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from \"@tanstack/react-query\";\nimport SuperJSON from \"superjson\";\n\nexport const createQueryClient = () =>\n  new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        serializeData: SuperJSON.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === \"pending\",\n      },\n      hydrate: {\n        deserializeData: SuperJSON.deserialize,\n      },\n    },\n  });\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/trpc/server.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/home/froeht/Code/PinPoint/src/utils/version.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
