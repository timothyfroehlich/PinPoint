/**
 * E2E – Anonymous Issue Creation via QR
 *
 * Validates the guest reporting journey end-to-end:
 * 1) QR endpoint resolves to the correct machine report URL.
 * 2) Anonymous user can submit the report form.
 * 3) Resulting issue remains inaccessible to guests (no edit/attachment access).
 *
 * Tests run in guest projects only; any admin setup happens via API requests
 * that reuse the auth storage generated by the auth-setup project.
 */

import { test, expect } from "@playwright/test";
import { randomUUID } from "node:crypto";
import postgres from "postgres";
import { SEED_TEST_IDS } from "../../src/test/constants/seed-test-ids";
import { Client } from "pg";

const MACHINE_ID = SEED_TEST_IDS.MACHINES.MEDIEVAL_MADNESS_1;
const MACHINE_DISPLAY_NAME =
  "Ultraman: Kaiju Rumble (Blood Sucker Edition) #1";

test.use({ storageState: undefined });

test.describe("Issue Create – Anonymous via QR (E2E)", () => {
  let qrCodeId: string;

  test.beforeAll(async () => {
    await ensureAnonymousReportingEnabled(MACHINE_ID);
    qrCodeId = await ensureQrCodeId(MACHINE_ID);
  });

  test.beforeEach(({ }, testInfo) => {
    if (testInfo.project.name.includes("auth")) {
      test.skip("Anonymous QR flow runs only on guest browsers");
    }
  });

  test("QR endpoint redirects to the machine report form", async ({ page }) => {
    const response = await page.request.fetch(`/api/qr/${qrCodeId}`, {
      maxRedirects: 0,
    });

    expect(response.status(), "QR endpoint should redirect").toBe(307);

    const locationHeader =
      response.headers()["location"] ?? response.headers()["Location"];

    expect(locationHeader).toBeTruthy();
    expect(locationHeader).toContain(
      `/machines/${MACHINE_ID}/report-issue`,
    );
  });

  test("anonymous user can submit the report form but cannot view the new issue", async ({
    page,
  }) => {
    await page.goto(`/report/${MACHINE_ID}`);

    await expect(
      page.getByRole("heading", { name: "Report an Issue" }),
    ).toBeVisible();
    await expect(
      page.locator("text=You're reporting a problem with"),
    ).toContainText(MACHINE_DISPLAY_NAME);
    await expect(page.getByTestId("machineId-hidden")).toHaveValue(MACHINE_ID);

    const title = `Anon QR issue ${Date.now()}`;
    await page.getByTestId("issue-title-input").fill(title);
    await page
      .getByTestId("issue-description-input")
      .fill("Scanned QR code to report intermittent power cycling.");
    await page
      .getByTestId("reporter-email-input")
      .fill(`qr-reporter+${Date.now()}@example.com`);

    await page.getByTestId("create-issue-submit").click();

    const createdIssueId = await waitForIssueCreation(title);

    await page.goto(`/issues/${createdIssueId}`, { waitUntil: "domcontentloaded" });
    await expect(
      page.getByRole("heading", { name: "Issue Access Required" }),
    ).toBeVisible();
  });
});

function createSqlClient() {
  const connectionString =
    process.env.POSTGRES_URL_NON_POOLING ?? process.env.DATABASE_URL;

  if (!connectionString) {
    throw new Error("Database connection string is not set");
  }

  return postgres(connectionString, { max: 1 });
}

async function ensureAnonymousReportingEnabled(machineId: string): Promise<void> {
  const sql = createSqlClient();
  try {
    await sql`
      UPDATE organizations
      SET allow_anonymous_issues = TRUE,
          is_public = TRUE
      WHERE id = ${SEED_TEST_IDS.ORGANIZATIONS.primary}
    `;

    await sql`
      UPDATE machines
      SET is_public = TRUE
      WHERE id = ${machineId}
    `;

    await sql`
      UPDATE issue_statuses
      SET is_default = (id = ${SEED_TEST_IDS.STATUSES.NEW_PRIMARY})
      WHERE organization_id = ${SEED_TEST_IDS.ORGANIZATIONS.primary}
    `;

    await sql`
      UPDATE priorities
      SET is_default = (id = ${SEED_TEST_IDS.PRIORITIES.MEDIUM_PRIMARY})
      WHERE organization_id = ${SEED_TEST_IDS.ORGANIZATIONS.primary}
    `;
  } finally {
    await sql.end({ timeout: 0 });
  }
}

async function ensureQrCodeId(machineId: string): Promise<string> {
  const sql = createSqlClient();

  try {
    const existing = await sql<{ qr_code_id: string | null }[]>`
      SELECT qr_code_id FROM machines WHERE id = ${machineId}
    `;

    const currentId = existing[0]?.qr_code_id;
    if (currentId) {
      return currentId;
    }

    const generatedQrId = `qr-${randomUUID()}`;
    await sql`
      UPDATE machines
      SET qr_code_id = ${generatedQrId},
          qr_code_url = NULL,
          qr_code_generated_at = NOW(),
          updated_at = NOW()
      WHERE id = ${machineId}
    `;

    return generatedQrId;
  } finally {
    await sql.end({ timeout: 0 });
  }
}

async function waitForIssueCreation(
  title: string,
  timeoutMs = 20_000,
): Promise<string> {
  const deadline = Date.now() + timeoutMs;
  while (Date.now() < deadline) {
    const sql = createSqlClient();
    try {
      const rows = await sql<{ id: string }[]>`
        SELECT id FROM issues
        WHERE title = ${title}
        ORDER BY created_at DESC
        LIMIT 1
      `;
      if (rows.length > 0) {
        return rows[0].id;
      }
    } finally {
      await sql.end({ timeout: 0 });
    }
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
  throw new Error("Issue creation not observed within timeout window");
}
